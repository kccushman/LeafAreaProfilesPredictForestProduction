---
title: "Prediction of forest aboveground net primary production from high-resolution vertical leaf-area profiles: Results"
author: "KC Cushman"
date: "November 28, 2018"
output:
  word_document: default
  html_document: default
---

```{r define leaf area algorithm, include=FALSE}
## Original MATLAB code from Detto et al. (2015) is commented out below.

  ##function [u,n,I,U] = leaf_area_density(z0,R,A,zi,tl,n)
  leaf_area_density <- function(z0,R,A,zi,tl,n){ 
    
    # Compute leaf area density profile from multireturn LiDAR cluod point using a stochastic
    # radiative transfer model
    #
    # reference:
      # Detto, M., G. Asner, Sonnentag, O. and H. C. Muller-Landau. 2015. Using stochastic radiative
    # transfer models to estimate leaf area density from multireturn LiDAR in
    # complex tropical forests. Journal of Geophysical Research.
    #
    
    
    # INPUTS:
    # z0: 1-D vector of vertical coordinates
    # R : 1-D vector of return numbers
    # A : 1-D vector of scan angles
    # zi: 1-D vector of discrete z-axis at which leaf area density will be computed
    # tl: leaf inclination model ('planophile','erectophile','spherical', or user defined)
    # n : matrix MxSxK number of points per return number, layer and
    # scan angle (optional for re-computing leaf area density with different leaf inclination)
    #
    
    
    # OUTPUTS:
      # u : 1-D vector of lead area density same size of zi
    # n : matrix MxSxK, number of points per return number, layer and scan angle
    # I : matrix MxSxK, probability for a beam with angle A to intercept fewer than k leaves up to depth zi
    # U : matrix MxSxK,the probability for a leaf at depth zi to be the kth contact along the beam path
    #
    # usage:
      # [u,n,I,U] = leaf_area_density(z0,R,A,zi,tl,[])
      # or
      # u = leaf_area_density(z0,R,A,zi,tl,n)
    
    ##dz=abs(zi(1)-zi(2));
    dz <- abs(zi[1]-zi[2])
    
    ##M=length(zi);
    M <- length(zi)
    
    ##A=abs(A);
    A <- abs(A)
    
    ##th(:,1)=unique(A);
    th <- unique(A)
    th <- th[order(th)]
    
    ##S=length(th);
    S <- length(th)
    
    ##K=max(R);
    K <- max(R)
    
    
    # compute n(z,s,k) - number of points per depth, scan angle and return number
    
    ##if isempty(n)
    if (is.null(n)){
    
      ##n=zeros(M,S,K);
      n <- array(0, dim=c(M,S,K))
      
      ##for i=1:M
      for(i in 1:M){
        ##use1=find(z0>zi(i) & z0<=zi(i)+dz);
        use1 <- which(z0>zi[i] & z0 <= (zi[i]+dz))
        
        ##for j=1:S
        for(j in 1:S){
          ##use2=A(use1)==th(j);
          use2 <- which(A[use1]==th[j])
          
          ##for k=1:K
          #% [i j k]
          for(k in 1:K){
            ##n(i,j,k)=sum(R(use1(use2))==k);
            n[i,j,k] <- sum(R[use1[use2]]==k)
          
            
            ##end
            ##end
            ##end  
          }
        }
      }
    
  
    ##n(isnan(n))=0;
      n[is.na(n)] <- 0
  
    ##end
    }
    
    # Delete second return if no first return
    if(K==2){
      for(i in 1:M){
        if(n[i,1,1]==0 & n[i,1,2]>0){
          n[i,1,2] <- 0
        }
      }
    }
    
    #%% compute penetration functions for each scan angle
    
    ##[I,U]=deal(zeros(M,S,K));
    I <- array(0, dim=c(M,S,K))
    U <- array(0, dim=c(M,S,K))
      
    ## [G,control]=deal(zeros(M,S));
    G <- array(0, dim=c(M,S))
    control <- array(0, dim=c(M,S))
    
    ##n0=zeros(S,1);
    n0 <- array(0, dim=c(S,1))
    
    ##for i=1:S
    for (i in 1:S){
      
      ##n0(i)=sum(R==1 & A==th(i));
      n0[i] <- sum(R==1 & A==th[i])
      
      ##n1=sum(n(:,i,:),3);
      n1 <- if(K==1) {n[,i,]} else {rowSums(n[,i,])}
      
      ##for j=1:K
      for (j in 1:K){
        #I(:,i,j)=1-cumsum((sum(n(:,i,j),2)))/n0(i);
        I[,i,j] <- 1- cumsum(n[,i,j])/n0[i]
        
        #U(:,i,j)=n(:,i,j)./n1;
        U[,i,j] <- n[,i,j]/n1
        
        #end
      }
      
        
      ##apply correction factor for limited available return (Eq. 5)
      #U(:,i,1)=U(:,i,1).*I(:,i,K);
      U[,i,1] <- U[,i,1]*I[,i,K]
        
      #control(:,i)=n1>0;
      control[,i] <- n1>0
        
      #G(:,i) = Gfunction(tl,th(i),zi);
      G[,i] = Gfunction(tl,th[i],zi)
      
    #end
    }
    
    ##%% compute leaf area density from ensemble across scan angles
    
    #p=sum(n(:,:,1),2);
    p <- if(S==1) {n[,,1]} else {rowSums(n[,,1])}
    
    #jj=find(p>0, 1 )-1;
    jj <- which(p>0)[1]-1
    
    #[alfa,beta,U0]=deal(nan(1,M));
    alfa <- array(NaN,dim=c(1,M))
    beta <- array(NaN,dim=c(1,M))
    U0 <- array(NaN,dim=c(1,M))
    
    #for i=1:M
    for(i in 1:M){
      #use=control(i,:)>0;
      use <- control[i,]>0
      
      #w=n0(use)./sum(n0(use));
      w <- n0[use]/sum(n0[use])
      
      #U0(i)=(G(i,:)./abs(cos(th'/180*pi)))*(n0./sum(n0));
      U0[i] <- (G[i,]/abs(cos(t(th)/180*pi)))%*%(n0/sum(n0))
  
      #if ~isempty(w)
      #%Eq. 8a
      #alfa(1,i)=1-I(i,use,1)*w;
      alfa[1,i] <- ifelse(length(w)>0, 1-I[i,use,1]%*%w, NaN)
      
      #%Eq. 8b
      #beta(1,i)=(U(i,use,1).*G(i,use)./abs(cos(th(use)'/180*pi)))*w;
      beta[1,i] <- ifelse(length(w)>0, (U[i,use,1]*G[i,use]/abs(cos(t(th[use])/180*pi)))%*%w, NaN)
  
    #end
    }
  
    #alfa(1:jj)=0;
    alfa[1:jj] <- ifelse(jj==0, alfa[1:jj], 0)
    
    #use=find(~isnan(alfa));
    use <- which(!is.na(alfa))
    
    #bad=find(isnan(alfa));
    bad <- which(is.na(alfa))
    
    #alfa(bad)=interp1(use,alfa(use),bad);
    alfa[bad] <- approx(x=use, y=alfa[use], xout=bad, method='linear', rule=2)[[2]]
    
    #beta(1:jj)=U0(1:jj);
    beta[1:jj] <- ifelse(jj==0, beta[1:jj], U0[1:jj])
    
    #use=find(~isnan(beta));
    use <- which(!is.na(beta))
    
    #bad=find(isnan(beta));
    bad <- which(is.na(beta))
    
    #beta(bad)=interp1(use,beta(use),bad);
    beta[bad] <- approx(x=use, y=beta[use], xout=bad, method='linear', rule=2)[[2]]
    
    #%numerical solution
    #u=zeros(M,1);
    u <- array(0,dim=c(M,1))
    
    #for i=jj:M
    for(i in max(c(1,jj)):M){
      #%Eq. 6
      #u(i)=(alfa(i)-beta(1:i-1)*u(1:i-1)*dz)./(beta(i)*dz);
      u[i] <- ifelse(i==1, (alfa[i])/(beta[i]*dz),(alfa[i]-beta[1:i-1]%*%u[1:i-1]*dz)/(beta[i]*dz))
      
      #if u(i)<0;u(i)=0;
      u[u<0] <- 0
      
    #end
    }
  
    #u(abs(u)==inf)=nan;
    u[is.infinite(abs(u))] <- NaN
    
    u[is.na(u)] <- 0
    U[is.na(U)] <- 0
    
    return(u)
    
    #end
  }
  
    ## %%%%%%%%%%%%%%%%%%%%%%%%%
    ##function G = Gfunction(LAD,ze,zi)
    ## % Compute Ross G function
    ## % ze in degrees
    ## % LAD: leaf angle distribution is given in radians
    Gfunction <- function(LAD, ze, zi){
      #ze=abs(ze)*pi/180;
      ze <- abs(ze)*pi/180
      
      #th=0:pi/200:pi/2;
      th <- seq(0,pi/2, length=101)
      
      #A=cos(ze)*cos(th);
      A <- cos(ze)*cos(th)
      
      #J=1./tan(th)*1/tan(ze);
      J <- (1/tan(th)*1)/tan(ze)
      
      #use=abs(J)<=1;
      use <- abs(J)<=1
      
      #phi=acos(J);
      phi <- acos(J)
      
      #A(use)=cos(th(use))*cos(ze).*(1+(2/pi)*(tan(phi(use))-phi(use)));
      A[use] <- cos(th[use])*cos(ze)*(1+(2/pi)*(tan(phi[use])-phi[use]))
      
      #DEFINE BETA BEFORE
      #G=zeros(length(zi),1);
      Gbeta <- array(0, dim=c(length(zi),1))
      
      for(i in 1:length(zi)){
        #ME=60-(60-22)*exp(-(zi(i)/25).^2);
        ME <- 60-(60-22)*exp(-(zi[i]/25)^2)
        
        #SD=20-(20-13)*exp(-(zi(i)/25).^2);
        SD <- 20-(20-13)*exp(-(zi[i]/25)^2)
        
        #t=2*th/pi;
        t <- 2*th/pi
        
        #tbar = ME/90;
        tbar <- ME/90
        
        #st=(SD/90)^2;
        st <- (SD/90)^2
        
        #s0=tbar*(1-tbar);
        s0 <- tbar*(1-tbar)
        
        #nu = tbar*(s0/st-1);
        nu <- tbar*(s0/st-1)
        
        #mu=(1-tbar)*(s0/st-1);
        mu <- (1-tbar)*(s0/st-1)
        
        #f = 1./beta(mu,nu)*(1-t).^(mu-1).*t.^(nu-1);
        f = 1/beta(mu,nu)*(1-t)^(mu-1)*t^(nu-1)
        
        #G(i,1)=trapz(t,A.*f);
        Gbeta[i,1] <- pracma::trapz(t,A*f)}
      
      #if strcmp(LAD,'planophile')
      G <- if (LAD=='planophile'){
        #f = 2/pi*(1+cos(2*th));G=trapz(th,A.*f);
        pracma::trapz(th, A*(2/pi*(1+cos(2*th))))
        
        #elseif strcmp(LAD,'erectophile')
      } else if (LAD=="erectophile"){
        #f = 2/pi*(1-cos(2*th));G=trapz(th,A.*f);
        pracma::trapz(th,A*(2/pi*(1-cos(2*th))))
        
        #elseif strcmp(LAD,'spherical')
      } else if (LAD=="spherical"){
        #G=0.5;
        0.5
        
        ##elseif strcmp(LAD,'beta')
      } else if (LAD=="beta"){
        Gbeta  
      }
      
      
    return(G)  
    #end  
    }
      
  
    ##%%
    ##  elseif strcmp(LAD,'Wirth') ## IGNORE THIS ONE FOR NOW
    ##G=zeros(length(zi),1);
    ##for i=1:length(zi)
    ##LAD=(8.0252*log(zi(i)) + 16.949)*pi/180;
    ##%Campbell
    ##chi=-3+(LAD/9.65)^(-0.6061);
    ##L=chi+asin(sqrt(1-chi^2))/sqrt(1-chi^2);
    ##f=2*chi^3*sin(th)./(L*(cos(th).^2.+chi^2*sin(th).^2).^2);
    ##G(i,1)=trapz(th,A.*f);
    ##end
    ##elseif length(LAD)>=1000
    ##f=hist(LAD,th);
    ##G=sum(A.*f/sum(f));
    ##elseif length(LAD)<1000 && length(LAD)>10
    ##t=2*th/pi;
    ##tbar = mean(LAD/90);
    ##st=var(LIA/90);
    ##s0=tbar*(1-tbar);
    ##nu = tbar*(s0/st-1);
    ##mu=(1-tbar)*(s0/st-1);
    ##f = 1./beta(mu,nu)*(1-t).^(mu-1).*t.^(nu-1);
    ##G=trapz(t,A.*f);
    #end
    #end
    
```

```{r extract lidar metrics, include=FALSE}
# Define a vector with all plot names
  plots <- c("A1","A2","A3","A4","A5","A6","L1","L2","L3","L4","L5","L6","P1","P2","P3","P4","P5","P6")

# Create a stat frame to store three structural metrics to calculate from LiDAR data, and the total number of returns per plot (Count).
  # 1. Vertical leaf area profiles (LAI)
  # 2. Total leaf area (TotalLAI)
  # 3. Discrete relative height percentiles (RH)
CARBONO <- data.frame(plot=plots, 
                      LAI=I(matrix(nrow=18,ncol=60,data=NA)),
                      Light_tra=I(matrix(nrow=18,ncol=60,data=NA)), Light_abs= I(matrix(nrow=18,ncol=60,data=NA)),
                      TotalLAI=NA, 
                      RH=I(matrix(nrow=18,ncol=60,data=NA)), 
                      Count=NA, Pulse=NA)
heights <- seq(60,1)

# For each CARBONO plot, calculate structural metrics
for(i in 1:length(plots)){
  # Load LiDAR tile for each plot
  tile <- paste("Plot_",plots[i],".las",sep="")
  data <- rLiDAR::readLAS(tile, short=F)

  # Calculate the ground elevation at each LiDAR return, and calculate height above ground for each return. Store in data[,14].

  # Use the leaf algorithm defined above to calculate the vertical leaf area profile.
  LAIprofile <- leaf_area_density(z0=data[,3],
                                  R=data[,5],
                                  A=data[,10],
                                  zi= heights,
                                  tl='spherical',
                                  n=NULL)
  CARBONO$LAI[i,1:60] <- LAIprofile
  
  # Sum the vertical leaf area profile to calculate total leaf area.
  CARBONO$TotalLAI[i] <- sum(LAIprofile)
  
  # Calculate discrete relative height percentiles.
  CARBONO$RH[i,1:60] <- quantile(data[,3], probs=seq(from=0,to=1,length.out=60))
  CARBONO$Count[i] <- length(data[,1])
  CARBONO$Pulse[i] <- length(data[data[,5]==1,1])
  # Calculate light absorbed by each height
  for(j in 1:length(heights)){
    CARBONO$Light_tra[i,j] <- 100*exp(-0.88*sum(CARBONO$LAI[i,1:(j)]))
    CARBONO$Light_abs[i,j] <- ifelse(j==1,100-CARBONO$Light_tra[i,j],CARBONO$Light_tra[i,j-1]-CARBONO$Light_tra[i,j])
  }
  
}

    # Re-scale relative light transmittance and absorption to have the same total magnitude as LAI values
    CARBONO$Light_tra <- CARBONO$Light_tra/(sum(CARBONO$Light_tra)/sum(CARBONO$LAI))
    CARBONO$Light_abs <- CARBONO$Light_abs/(sum(CARBONO$Light_abs)/sum(CARBONO$LAI))

```

```{r CARBONO ANPP data, include=FALSE}

# Create vectors to store wood and litter production data for the relevant sampling periods.
CARBONO$Wood.08.09 <- NA
CARBONO$Wood.09.10 <- NA
CARBONO$Litter.08.09 <- NA
CARBONO$Litter.09.10 <- NA
CARBONO$WSG <- NA

## CARBONO ANPP - WOOD PRODUCTION

    # Get Wood production data per plot
    Wood <- read.csv("Wood.csv")
    
    # Make a plot variable
    Wood$plot <- substr(Wood$plot_treeid,start=1,stop=2)
    
    # Calculate AGB from allometric equation for each stem
    
      # Define function (agb.allometry) to estimate aboveground biomass from wood specific 
      # gravity (wsg), tree diameter in centimeters (dbh). 
      agb.allometry <- function(E,wsg,dbh){exp(-1.803-0.976*E+0.976*log(wsg) + 2.673*log(dbh) - 0.0299*(log(dbh)^2))}
    
      # Retrieve values of E for each plot using database from Chave et al. 2014
      # Call in source info:
      # source("http://chave.ups-tlse.fr/pantropical_allometry/readlayers.r")
      # Define coordinates of La Selva:
      # LS.coord <- cbind(-84.00,10.43); E.LaSelva <- retrieve_raster("E",LS.coord)
        E.LaSelva <- -0.06340053
        
      # Merge with other datasets to assign wood density to each stem
        TreeIDs <- read.csv("TreeIDs.csv") #Tree species from ID for each stem
        Species <- read.csv("Species.csv") #Wood density from species
        
        Wood <- merge(x=Wood, y=TreeIDs[,c("plot_treeid","genspcode")])
        Wood <- merge(x=Wood, y=Species[,c("genspcode","family","wooddens")], all.x=T)
        
          # First, fill in missing wood density values with family-level average
          FamilyWSG <- aggregate(Species$wooddens, by=list(Species$family), FUN="mean", na.rm=T)
          names(FamilyWSG) <- c("family","wooddens.family")
          
          Wood <- merge(x=Wood, y=FamilyWSG, all.x=T)
          
          Wood[is.na(Wood$wooddens),"wooddens"] <- Wood[is.na(Wood$wooddens),"wooddens.family"]
          
          # Second, fill in remaining missing wood density values with site-level average
          SiteWSG <- mean(Wood[!duplicated(Wood$plot_treeid),'wooddens'], na.rm=T)
          Wood[is.na(Wood$wooddens),"wooddens"] <- SiteWSG
          
        # Calculate AGB (convert diameter to cm)
        Wood$AGB <- agb.allometry(E.LaSelva, Wood$wooddens, Wood$dia_calc/10)

      
        
    
    # Calculate wood production for 2008-2009
    for(i in 1:length(plots)){
      # Trees present in initial census
        initial.trees <- droplevels(Wood[Wood$plot==plots[i] & Wood$dia_year==2008 & !(Wood$EBMkg_SB==-999), 'plot_treeid'])
      # Trees present in final census
        final.trees <- droplevels(Wood[Wood$plot==plots[i] & Wood$dia_year==2009 & !(Wood$EBMkg_SB==-999), 'plot_treeid'])
      # Trees that were present in initial and final census to calculate wood production
        growth.trees <- droplevels(final.trees[final.trees %in% initial.trees])
      # Sum initial biomass
        Wood.initial <- sum(Wood[Wood$plot_treeid %in% growth.trees & Wood$dia_year==2008, 'AGB'])
      # Sum final biomass
        Wood.final <- sum(Wood[Wood$plot_treeid %in% growth.trees & Wood$dia_year==2009, 'AGB'])
      # Calculate growth and convert from kg to Mg/ha
        CARBONO$Wood.08.09[i] <- 2*(Wood.final-Wood.initial)/1000
    }
    
    # Calculate wood production for 2009-2010
    for(i in 1:length(plots)){
      # Trees present in initial census
        initial.trees <- droplevels(Wood[Wood$plot==plots[i] & Wood$dia_year==2009 & !(Wood$EBMkg_SB==-999), 'plot_treeid'])
      # Trees present in final census
        final.trees <- droplevels(Wood[Wood$plot==plots[i] & Wood$dia_year==2010 & !(Wood$EBMkg_SB==-999), 'plot_treeid'])
      # Trees that were present in initial and final census to calculate wood production
        growth.trees <- droplevels(final.trees[final.trees %in% initial.trees])
      # Sum initial biomass
        Wood.initial <- sum(Wood[Wood$plot_treeid %in% growth.trees & Wood$dia_year==2009, 'AGB'])
      # Sum final biomass
        Wood.final <- sum(Wood[Wood$plot_treeid %in% growth.trees & Wood$dia_year==2010, 'AGB'])
      # Calculate growth and convert from kg to Mg/ha
        CARBONO$Wood.09.10[i] <- 2*(Wood.final-Wood.initial)/1000 
    }
        
  # Calculate biomass-weighted mean wood density for 2009
    for(i in 1:length(plots)){
      # Trees present in initial census
        CARBONO$WSG[i] <- weighted.mean(x=Wood[Wood$plot==plots[i] & Wood$dia_year==2009 & !(Wood$EBMkg_SB==-999), 'wooddens'],
                                        w=Wood[Wood$plot==plots[i] & Wood$dia_year==2009 & !(Wood$EBMkg_SB==-999), 'AGB'])
    }
    
  # Record the average wood production of the two sampling periods
    CARBONO$Wood <- (CARBONO$Wood.08.09+CARBONO$Wood.09.10)/2

## CARBONO ANPP - LITTER PRODUCTION
  # Get litter production data per plot
    Litter <- read.csv("Litter.csv")
  
  # Record value for litter produced in each plot
    for(i in 1:length(plots)){
      CARBONO$Litter.08.09[i] <- Litter[Litter$Plot==plots[i] & Litter$Year1==2008,"Litter.Mghayr"]
      CARBONO$Litter.09.10[i] <- Litter[Litter$Plot==plots[i] & Litter$Year1==2009,"Litter.Mghayr"]
    }

  # Record the average litter production of the two sampling periods
    CARBONO$Litter <- (CARBONO$Litter.08.09+CARBONO$Litter.09.10)/2

# Make a variable for CARBONO plot type  
  CARBONO$Type <- substr(CARBONO$plot, start = 1, stop=1)

# Make a variable for total ANPP
  CARBONO$ANPP <- CARBONO$Litter + CARBONO$Wood

# Only keep columns needed for further analyses
  CARBONO <- CARBONO[,c('plot','Type','Wood','Litter','ANPP','TotalLAI','LAI','RH','Count','Pulse','WSG','Light_tra','Light_abs')]

## How much ANPP variation is explained by soil type alone?
Type_ANOVA <- lm(ANPP~Type, data=CARBONO)

```

```{r PLSR, include=FALSE}
library(pls)

## Predict ANPP from leaf-area profiles using a partial least squares analysis

# Randomly split half of plots for training model and half for testing model- repeat many times to create confidence intervals
  niter <- 1000 # Define number of times to repeate random sampling
  testsize <- 9 # Define number of plots to leave for model testing

# Create data frames to store result from leaf-area profile PLS models to predict litter production, wood production, and total ANPP
  LitterRpt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)
  WoodRpt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)
  TotalRpt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)

# Create data frames to store result from total leaf area models to predict litter production, wood production, and total ANPP  
  LitterLAIRpt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)
  WoodLAIRpt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)
  TotalLAIRpt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)

# Create data frames to store result from lidar discrete RH models to predict litter production, wood production, and total ANPP
  LitterRHRpt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)
  WoodRHRpt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)
  TotalRHRpt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)

# Create data frames to store observed values of litter production, wood production, and total ANPP for validation plots
  LitterValuesObserved <- matrix(nrow=testsize, ncol=niter, data=NA)
  WoodValuesObserved <- matrix(nrow=testsize, ncol=niter, data=NA)
  TotalValuesObserved <- matrix(nrow=testsize, ncol=niter, data=NA)

# Create data frames to store predicted (leaf-area profile PLS) values of litter production, wood production, and total ANPP for validation plots  
  LitterValuesPredicted <- matrix(nrow=testsize, ncol=niter, data=NA)
  WoodValuesPredicted <- matrix(nrow=testsize, ncol=niter, data=NA)
  TotalValuesPredicted <- matrix(nrow=testsize, ncol=niter, data=NA)

# Create data frames to store predicted (total leaf area) values of litter production, wood production, and total ANPP for validation plots  
  LitterValuesPredictedLAI <- matrix(nrow=testsize, ncol=niter, data=NA)
  WoodValuesPredictedLAI <- matrix(nrow=testsize, ncol=niter, data=NA)
  TotalValuesPredictedLAI <- matrix(nrow=testsize, ncol=niter, data=NA)

# Create data frames to store predicted (lidar discrete RH) values of litter production, wood production, and total ANPP for validation plots  
  LitterValuesPredictedRH <- matrix(nrow=testsize, ncol=niter, data=NA)
  WoodValuesPredictedRH <- matrix(nrow=testsize, ncol=niter, data=NA)
  TotalValuesPredictedRH <- matrix(nrow=testsize, ncol=niter, data=NA)

# Create data frames to record the index number and plot IDs of each random subset 
  TestPlotIDs <- matrix(nrow=testsize, ncol=niter, data=NA)
  SampleList <- matrix(nrow=niter,ncol=(18-testsize),data=NA)

# Randomly select plots
  # Use set.seed(1) so analysis is repeatable
    set.seed(1) 

  for(i in 1:niter){
    SampleList[i,] <- sample(1:18,size=(18-testsize), replace=F)
  }

# How much wood variation is explained in the training dataset?
    LitterVar <- matrix(nrow=niter, ncol=3, data=NA)
    WoodVar <- matrix(nrow=niter, ncol=3, data=NA)
    TotalVar <- matrix(nrow=niter, ncol=3, data=NA)
    
# For each sample, predict litter production, wood production, and total ANPP using three methods.  
for(i in 1:niter){
  # Split data into subsets for model training (LAI train) and model testing (LAI test)
    LAItrain <- CARBONO[SampleList[i,],]
    LAItest <- CARBONO[-SampleList[i,],]
  # Record the IDs of plots used for model testing
    TestPlotIDs[,i] <- substr(LAItest$plot, start=1, stop=1)
  
  # Fit PLS models to predict litter production, wood production, and total ANPP from leaf-area profiles
    Litter.PLS <- pls::plsr(Litter~LAI, ncomp=3, data=LAItrain, validation="LOO")
      LitterRpt[i,"fitx"] <- sum(pls::explvar(Litter.PLS))
      LitterRpt[i,"fity"] <- 100*drop(pls::R2(Litter.PLS, estimate = "train",intercept = FALSE)$val)[3]
    Wood.PLS <- pls::plsr(Wood~LAI, ncomp=3, data=LAItrain, validation="LOO")
      WoodRpt[i,"fitx"] <- sum(pls::explvar(Wood.PLS))
      WoodRpt[i,"fity"] <- 100*drop(pls::R2(Wood.PLS, estimate = "train",intercept = FALSE)$val)[3]
    Total.PLS <- pls::plsr(ANPP~LAI, ncomp=3, data=LAItrain, validation="LOO")
      TotalRpt[i,"fitx"] <- sum(pls::explvar(Total.PLS))
      TotalRpt[i,"fity"] <- 100*drop(pls::R2(Total.PLS, estimate = "train",intercept = FALSE)$val)[3]
      
  # Fit PLS models to predict litter production, wood production, and total ANPP from lidar DRH profiles  
    LitterRH.PLS <- pls::plsr(Litter~RH, ncomp=3, data=LAItrain, validation="LOO")
    WoodRH.PLS <- pls::plsr(Wood~RH, ncomp=3, data=LAItrain, validation="LOO")
    TotalRH.PLS <- pls::plsr(ANPP~RH, ncomp=3, data=LAItrain, validation="LOO")
  
  # Fit linear models to predict litter production, wood production, and total ANPP from total leaf area
    Litter.LAI <- lm(Litter~TotalLAI, data=LAItrain)
    Wood.LAI <- lm(Wood~TotalLAI, data=LAItrain)
    Total.LAI <- lm(ANPP~TotalLAI, data=LAItrain)

  # Record observed litter production values for the validation subset, and predict litter production values for each model
    LitterValuesObserved[,i] <- LAItest$Litter
    LitterValuesPredicted[,i] <- predict(Litter.PLS, ncomp=3, newdata=LAItest)
    LitterValuesPredictedLAI[,i] <- predict(Litter.LAI, newdata=LAItest)
    LitterValuesPredictedRH[,i] <- predict(LitterRH.PLS, ncomp=3, newdata=LAItest)

  # Record observed wood production values for the validation subset, and predict litter production values for each model
    WoodValuesObserved[,i] <- LAItest$Wood
    WoodValuesPredicted[,i] <- predict(Wood.PLS, ncomp=3, newdata=LAItest)
    WoodValuesPredictedLAI[,i] <- predict(Wood.LAI, newdata=LAItest)
    WoodValuesPredictedRH[,i] <- predict(WoodRH.PLS, ncomp=3, newdata=LAItest)

  # Record observed total ANPP values for the validation subset, and predict litter production values for each model
    TotalValuesObserved[,i] <- LAItest$ANPP
    TotalValuesPredicted[,i] <- predict(Total.PLS, ncomp=3, newdata=LAItest)
    TotalValuesPredictedLAI[,i] <- predict(Total.LAI, newdata=LAItest)
    TotalValuesPredictedRH[,i] <- predict(TotalRH.PLS, ncomp=3, newdata=LAItest)

  # Fit a pearson correlation between predicted and observed litter production using leaf-area profiles, and record p-value.
  # Fit a model of predicted and observed litter production using leaf-area profiles, and record intercept, slope, and r-squared values.
    # Deming regression
    LitterDeming <- mcr::mcreg(LitterValuesPredicted[,i],LAItest$Litter,method.reg="Deming",error.ratio=1,method.ci="analytical")
    LitterRpt[i,1] <- cor.test(x=LitterValuesPredicted[,i], y=LAItest$Litter, method="pearson")$p.value
    LitterRpt[i,2] <- mcr::getCoefficients(LitterDeming)[1,1]
    LitterRpt[i,3] <- mcr::getCoefficients(LitterDeming)[2,1]
    LitterRpt[i,4] <- cor.test(x=LitterValuesPredicted[,i], y=LAItest$Litter, method="pearson")$estimate^2
  
  # Fit a pearson correlation between predicted and observed wood production using leaf-area profiles, and record p-value.
  # Fit a model of predicted and observed wood production using leaf-area profiles, and record intercept, slope, and r-squared values.   
    # Deming regression
    WoodDeming <- mcr::mcreg(WoodValuesPredicted[,i],LAItest$Wood,method.reg="Deming",error.ratio=1,method.ci="analytical")
    WoodRpt[i,1] <- cor.test(x=WoodValuesPredicted[,i], y=LAItest$Wood, method="pearson")$p.value
    WoodRpt[i,2] <- mcr::getCoefficients(WoodDeming)[1,1]
    WoodRpt[i,3] <- mcr::getCoefficients(WoodDeming)[2,1]
    WoodRpt[i,4] <- cor.test(x=WoodValuesPredicted[,i], y=LAItest$Wood, method="pearson")$estimate^2
  
  # Fit a pearson correlation between predicted and observed total ANPP using leaf-area profiles, and record p-value.
  # Fit a model of predicted and observed total ANPP using leaf-area profiles, and record intercept, slope, and r-squared values.   
    # Deming regression instead
    TotalDeming <- mcr::mcreg(TotalValuesPredicted[,i],LAItest$ANPP,method.reg="Deming",error.ratio=1,method.ci="analytical")
    TotalRpt[i,1] <- cor.test(x=TotalValuesPredicted[,i], y=LAItest$ANPP, method="pearson")$p.value
    TotalRpt[i,2] <- mcr::getCoefficients(TotalDeming)[1,1]
    TotalRpt[i,3] <- mcr::getCoefficients(TotalDeming)[2,1]
    TotalRpt[i,4] <- cor.test(x=TotalValuesPredicted[,i], y=LAItest$ANPP, method="pearson")$estimate^2
 
  # Fit a pearson correlation between predicted and observed litter production using total leaf area, and record p-value.
  # Fit a model of predicted and observed litter production using total leaf area, and record intercept, slope, and r-squared values.   
    # Deming regression instead
    LitterDeming <- mcr::mcreg(LitterValuesPredictedLAI[,i],LAItest$Litter,method.reg="Deming",error.ratio=1,method.ci="analytical")
    LitterLAIRpt[i,1] <- cor.test(x=LitterValuesPredictedLAI[,i], y=LAItest$Litter, method="pearson")$p.value
    LitterLAIRpt[i,2] <- mcr::getCoefficients(LitterDeming)[1,1]
    LitterLAIRpt[i,3] <- mcr::getCoefficients(LitterDeming)[2,1]
    LitterLAIRpt[i,4] <- cor.test(x=LitterValuesPredictedLAI[,i], y=LAItest$Litter, method="pearson")$estimate^2
    
  # Fit a pearson correlation between predicted and observed wood production using total leaf area, and record p-value.
  # Fit a model of predicted and observed wood production using total leaf area, and record intercept, slope, and r-squared values.      
    # Deming regression instead
    WoodDeming <- mcr::mcreg(WoodValuesPredictedLAI[,i],LAItest$Wood,method.reg="Deming",error.ratio=1,method.ci="analytical")
    WoodLAIRpt[i,1] <- cor.test(x=WoodValuesPredictedLAI[,i], y=LAItest$Wood, method="pearson")$p.value
    WoodLAIRpt[i,2] <- mcr::getCoefficients(WoodDeming)[1,1]
    WoodLAIRpt[i,3] <- mcr::getCoefficients(WoodDeming)[2,1]
    WoodLAIRpt[i,4] <- cor.test(x=WoodValuesPredictedLAI[,i], y=LAItest$Wood, method="pearson")$estimate^2
    
  # Fit a pearson correlation between predicted and observed total ANPP using total leaf area, and record p-value.
  # Fit a model of predicted and observed total ANPP using total leaf area, and record intercept, slope, and r-squared values.      
    # Deming regression
    TotalDeming <- mcr::mcreg(TotalValuesPredictedLAI[,i],LAItest$ANPP,method.reg="Deming",error.ratio=1,method.ci="analytical")
    TotalLAIRpt[i,1] <- cor.test(x=TotalValuesPredictedLAI[,i], y=LAItest$ANPP, method="pearson")$p.value
    TotalLAIRpt[i,2] <- mcr::getCoefficients(TotalDeming)[1,1]
    TotalLAIRpt[i,3] <- mcr::getCoefficients(TotalDeming)[2,1]
    TotalLAIRpt[i,4] <- cor.test(x=TotalValuesPredictedLAI[,i], y=LAItest$ANPP, method="pearson")$estimate^2
    
    
  # Fit a pearson correlation between predicted and observed litter production using lidar DRH profiles, and record p-value.
  # Fit a model of predicted and observed litter production using lidar DRH profiles, and record intercept, slope, and r-squared values. 
    # Deming regression instead
    LitterDeming <- mcr::mcreg(LitterValuesPredictedRH[,i],LAItest$Litter,method.reg="Deming",error.ratio=1,method.ci="analytical")
    LitterRHRpt[i,1] <- cor.test(x=LitterValuesPredictedRH[,i], y=LAItest$Litter, method="pearson")$p.value
    LitterRHRpt[i,2] <- mcr::getCoefficients(LitterDeming)[1,1]
    LitterRHRpt[i,3] <- mcr::getCoefficients(LitterDeming)[2,1]
    LitterRHRpt[i,4] <- cor.test(x=LitterValuesPredictedRH[,i], y=LAItest$Litter, method="pearson")$estimate^2
 
  # Fit a pearson correlation between predicted and observed wood production using lidar DRH profiles, and record p-value.
  # Fit a model of predicted and observed wood production using lidar DRH profiles, and record intercept, slope, and r-squared values.   
    # Deming regression instead
    WoodDeming <- mcr::mcreg(WoodValuesPredictedRH[,i],LAItest$Wood,method.reg="Deming",error.ratio=1,method.ci="analytical")
    WoodRHRpt[i,1] <- cor.test(x=WoodValuesPredictedRH[,i], y=LAItest$Wood, method="pearson")$p.value
    WoodRHRpt[i,2] <- mcr::getCoefficients(WoodDeming)[1,1]
    WoodRHRpt[i,3] <- mcr::getCoefficients(WoodDeming)[2,1]
    WoodRHRpt[i,4] <- cor.test(x=WoodValuesPredictedRH[,i], y=LAItest$Wood, method="pearson")$estimate^2
    
  # Fit a pearson correlation between predicted and observed total ANPP using lidar DRH profiles, and record p-value.
  # Fit a model of predicted and observed total ANPP using lidar DRH profiles, and record intercept, slope, and r-squared values.        
    # Deming regression
    TotalDeming <- mcr::mcreg(TotalValuesPredictedRH[,i],LAItest$ANPP,method.reg="Deming",error.ratio=1,method.ci="analytical")
    TotalRHRpt[i,1] <- cor.test(x=TotalValuesPredictedRH[,i], y=LAItest$ANPP, method="pearson")$p.value
    TotalRHRpt[i,2] <- mcr::getCoefficients(TotalDeming)[1,1]
    TotalRHRpt[i,3] <- mcr::getCoefficients(TotalDeming)[2,1]
    TotalRHRpt[i,4] <- cor.test(x=TotalValuesPredictedRH[,i], y=LAItest$ANPP, method="pearson")$estimate^2
    
  # How much variance is explained by the PLS model   
    LitterVar[i,1] <- 100*drop(pls::R2(Litter.PLS, estimate = "train",intercept = FALSE)$val)[1]
    LitterVar[i,2] <- 100*drop(pls::R2(Litter.PLS, estimate = "train",intercept = FALSE)$val)[2]
    LitterVar[i,3] <- 100*drop(pls::R2(Litter.PLS, estimate = "train",intercept = FALSE)$val)[3]
    WoodVar[i,1] <- 100*drop(pls::R2(Wood.PLS, estimate = "train",intercept = FALSE)$val)[1]
    WoodVar[i,2] <- 100*drop(pls::R2(Wood.PLS, estimate = "train",intercept = FALSE)$val)[2]
    WoodVar[i,3] <- 100*drop(pls::R2(Wood.PLS, estimate = "train",intercept = FALSE)$val)[3]
    TotalVar[i,1] <- 100*drop(pls::R2(Total.PLS, estimate = "train",intercept = FALSE)$val)[1]
    TotalVar[i,2] <- 100*drop(pls::R2(Total.PLS, estimate = "train",intercept = FALSE)$val)[2]
    TotalVar[i,3] <- 100*drop(pls::R2(Total.PLS, estimate = "train",intercept = FALSE)$val)[3]
    
    }

# Create data frames to store summary results from repeated sampling for leaf-area profile models.    
  LitterQuantiles <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  WoodQuantiles <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  TotalQuantiles <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  
# Create data frames to store summary results from repeated sampling for total leaf area models.
  WoodLAIQuantiles <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  LitterLAIQuantiles <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  TotalLAIQuantiles <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  
# Create data frames to store summary results from repeated sampling for lidar DRH profile models.
  WoodRHQuantiles <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  LitterRHQuantiles <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  TotalRHQuantiles <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)

# Loop through each column (p-value, intercenpt, slope, and r-squared), compute summary statistics.
  for(i in 1:4){
    LitterQuantiles[i,c("lower","median","upper")] <- quantile(x=LitterRpt[,i], probs=c(0.025,0.5,0.975))
    LitterQuantiles[i,c("mean")] <- mean(LitterRpt[,i])
    WoodQuantiles[i,c("lower","median","upper")] <- quantile(x=WoodRpt[,i], probs=c(0.025,0.5,0.975))
    WoodQuantiles[i,c("mean")] <- mean(WoodRpt[,i])
    TotalQuantiles[i,c("lower","median","upper")] <- quantile(x=TotalRpt[,i], probs=c(0.025,0.5,0.975))
    TotalQuantiles[i,c("mean")] <- mean(TotalRpt[,i])
    
    LitterLAIQuantiles[i,c("lower","median","upper")] <- quantile(x=LitterLAIRpt[,i], probs=c(0.025,0.5,0.975))
    LitterLAIQuantiles[i,c("mean")] <- mean(LitterLAIRpt[,i])
    WoodLAIQuantiles[i,c("lower","median","upper")] <- quantile(x=WoodLAIRpt[,i], probs=c(0.025,0.5,0.975))
    WoodLAIQuantiles[i,c("mean")] <- mean(WoodLAIRpt[,i])
    TotalLAIQuantiles[i,c("lower","median","upper")] <- quantile(x=TotalLAIRpt[,i], probs=c(0.025,0.5,0.975))
    TotalLAIQuantiles[i,c("mean")] <- mean(TotalLAIRpt[,i])
    
    LitterRHQuantiles[i,c("lower","median","upper")] <- quantile(x=LitterRHRpt[,i], probs=c(0.025,0.5,0.975))
    LitterRHQuantiles[i,c("mean")] <- mean(LitterRHRpt[,i])
    WoodRHQuantiles[i,c("lower","median","upper")] <- quantile(x=WoodRHRpt[,i], probs=c(0.025,0.5,0.975))
    WoodRHQuantiles[i,c("mean")] <- mean(WoodRHRpt[,i])
    TotalRHQuantiles[i,c("lower","median","upper")] <- quantile(x=TotalRHRpt[,i], probs=c(0.025,0.5,0.975))
    TotalRHQuantiles[i,c("mean")] <- mean(TotalRHRpt[,i])
  }

# Calculate component loadings values for leaf-area profile PLS models

  # Create matrices to store total ANPP loadings for the first 3 components, and total combined weights
  TotalC1Loadings <- matrix(nrow = 60, ncol=niter, data=NA)
  TotalC2Loadings <- matrix(nrow = 60, ncol=niter, data=NA)
  TotalC3Loadings <- matrix(nrow = 60, ncol=niter, data=NA)
  TotalWeights <- matrix(nrow = 60, ncol=niter, data=NA)
  
  # Record the loading values for each random sample PLS
  for(i in 1:niter){
    # Fit PLS model
      LAItrain <- CARBONO[SampleList[i,],]
      LAItest <- CARBONO[-SampleList[i,],]
      Litter.PLS <- pls::plsr(ANPP~LAI, ncomp=3, data=LAItrain, validation="LOO")
      Wood.PLS <- pls::plsr(ANPP~LAI, ncomp=3, data=LAItrain, validation="LOO")
      Total.PLS <- pls::plsr(ANPP~LAI, ncomp=3, data=LAItrain, validation="LOO")
      
    # Record first three component values
      TotalC1Loadings[,i] <- Total.PLS$loadings[,1]
      TotalC2Loadings[,i] <- Total.PLS$loadings[,2]
      TotalC3Loadings[,i] <- Total.PLS$loadings[,3]
    
    # Calculate the proportion of variation explained by each component
      Comp1Var <- 100*drop(pls::R2(Total.PLS, estimate = "train",intercept = FALSE)$val)[1]
      Comp2Var <- 100*drop(pls::R2(Total.PLS, estimate = "train",intercept = FALSE)$val)[2]-Comp1Var
      Comp3Var <- 100*drop(pls::R2(Total.PLS, estimate = "train",intercept = FALSE)$val)[3]-Comp1Var-Comp2Var
        # Calculate the combined loadings, weighted by that amoung of variation explained by each component 
        TotalWeights[,i] <- Total.PLS$loadings[,1]*Comp1Var + Total.PLS$loadings[,2]*Comp2Var + Total.PLS$loadings[,3]*Comp3Var
  }
  
  # Create data frames to store loading summary statistics
    TotalC1LoadingsSummary <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    TotalC2LoadingsSummary <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    TotalC3LoadingsSummary <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    TotalWeightsSummary <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
  # Calculate summary statistics
    for(i in 1:60){
      TotalC1LoadingsSummary[i,c('min','median','max')] <- quantile(TotalC1Loadings[i,], probs=c(0.025,0.5,0.975))
        TotalC1LoadingsSummary[i,'mean'] <- mean(TotalC1Loadings[i,])
      TotalC2LoadingsSummary[i,c('min','median','max')] <- quantile(TotalC2Loadings[i,], probs=c(0.025,0.5,0.975))
        TotalC2LoadingsSummary[i,'mean'] <- mean(TotalC2Loadings[i,])
      TotalC3LoadingsSummary[i,c('min','median','max')] <- quantile(TotalC3Loadings[i,], probs=c(0.025,0.5,0.975))
        TotalC3LoadingsSummary[i,'mean'] <- mean(TotalC3Loadings[i,])
      TotalWeightsSummary[i,c('min','median','max')] <- quantile(TotalWeights[i,], probs=c(0.025,0.5,0.975))
        TotalWeightsSummary[i,'mean'] <- mean(TotalWeights[i,])
    }

  # Repeat to calculate loadings for litter production PLS models
    LitterC1Loadings <- matrix(nrow = 60, ncol=niter, data=NA)
    LitterC2Loadings <- matrix(nrow = 60, ncol=niter, data=NA)
    LitterC3Loadings <- matrix(nrow = 60, ncol=niter, data=NA)
    LitterWeights <- matrix(nrow = 60, ncol=niter, data=NA)
    
    for(i in 1:niter){
      LAItrain <- CARBONO[SampleList[i,],]
      LAItest <- CARBONO[-SampleList[i,],]
      Litter.PLS <- pls::plsr(Litter~LAI, ncomp=3, data=LAItrain, validation="LOO")
      LitterC1Loadings[,i] <- Litter.PLS$loadings[,1]
      LitterC2Loadings[,i] <- Litter.PLS$loadings[,2]
      LitterC3Loadings[,i] <- Litter.PLS$loadings[,3]
      
      Comp1Var <- 100*drop(pls::R2(Litter.PLS, estimate = "train",intercept = FALSE)$val)[1]
      Comp2Var <- 100*drop(pls::R2(Litter.PLS, estimate = "train",intercept = FALSE)$val)[2]-Comp1Var
      Comp3Var <- 100*drop(pls::R2(Litter.PLS, estimate = "train",intercept = FALSE)$val)[3]-Comp1Var-Comp2Var
      
      LitterWeights[,i] <- Litter.PLS$loadings[,1]*Comp1Var + Litter.PLS$loadings[,2]*Comp2Var + Litter.PLS$loadings[,3]*Comp3Var
    }
    
    LitterC1LoadingsSummary <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    LitterC2LoadingsSummary <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    LitterC3LoadingsSummary <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    LitterWeightsSummary <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    
    for(i in 1:60){
      LitterC1LoadingsSummary[i,c('min','median','max')] <- quantile(LitterC1Loadings[i,], probs=c(0.025,0.5,0.975))
        LitterC1LoadingsSummary[i,'mean'] <- mean(LitterC1Loadings[i,])
      LitterC2LoadingsSummary[i,c('min','median','max')] <- quantile(LitterC2Loadings[i,], probs=c(0.025,0.5,0.975))
        LitterC2LoadingsSummary[i,'mean'] <- mean(LitterC2Loadings[i,])
      LitterC3LoadingsSummary[i,c('min','median','max')] <- quantile(LitterC3Loadings[i,], probs=c(0.025,0.5,0.975))
        LitterC3LoadingsSummary[i,'mean'] <- mean(LitterC3Loadings[i,])
      LitterWeightsSummary[i,c('min','median','max')] <- quantile(LitterWeights[i,], probs=c(0.025,0.5,0.975))
        LitterWeightsSummary[i,'mean'] <- mean(LitterWeights[i,])
    }
  
  # Repeat to calculate loadings for wood production PLS models
    WoodC1Loadings <- matrix(nrow = 60, ncol=niter, data=NA)
    WoodC2Loadings <- matrix(nrow = 60, ncol=niter, data=NA)
    WoodC3Loadings <- matrix(nrow = 60, ncol=niter, data=NA)
    WoodWeights <- matrix(nrow = 60, ncol=niter, data=NA)
    
    for(i in 1:niter){
      LAItrain <- CARBONO[SampleList[i,],]
      LAItest <- CARBONO[-SampleList[i,],]
      Wood.PLS <- pls::plsr(Wood~LAI, ncomp=3, data=LAItrain, validation="LOO")
      WoodC1Loadings[,i] <- Wood.PLS$loadings[,1]
      WoodC2Loadings[,i] <- Wood.PLS$loadings[,2]
      WoodC3Loadings[,i] <- Wood.PLS$loadings[,3]
      
      Comp1Var <- 100*drop(pls::R2(Wood.PLS, estimate = "train",intercept = FALSE)$val)[1]
      Comp2Var <- 100*drop(pls::R2(Wood.PLS, estimate = "train",intercept = FALSE)$val)[2]-Comp1Var
      Comp3Var <- 100*drop(pls::R2(Wood.PLS, estimate = "train",intercept = FALSE)$val)[3]-Comp1Var-Comp2Var
      
      WoodWeights[,i] <- Wood.PLS$loadings[,1]*Comp1Var + Wood.PLS$loadings[,2]*Comp2Var + Wood.PLS$loadings[,3]*Comp3Var
    }
    
    WoodC1LoadingsSummary <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    WoodC2LoadingsSummary <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    WoodC3LoadingsSummary <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    WoodWeightsSummary <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    
    for(i in 1:60){
      WoodC1LoadingsSummary[i,c('min','median','max')] <- quantile(WoodC1Loadings[i,], probs=c(0.025,0.5,0.975))
        WoodC1LoadingsSummary[i,'mean'] <- mean(WoodC1Loadings[i,])
      WoodC2LoadingsSummary[i,c('min','median','max')] <- quantile(WoodC2Loadings[i,], probs=c(0.025,0.5,0.975))
        WoodC2LoadingsSummary[i,'mean'] <- mean(WoodC2Loadings[i,])
      WoodC3LoadingsSummary[i,c('min','median','max')] <- quantile(WoodC3Loadings[i,], probs=c(0.025,0.5,0.975))
        WoodC3LoadingsSummary[i,'mean'] <- mean(WoodC3Loadings[i,])
      WoodWeightsSummary[i,c('min','median','max')] <- quantile(WoodWeights[i,], probs=c(0.025,0.5,0.975))
        WoodWeightsSummary[i,'mean'] <- mean(WoodWeights[i,])
    }
```

```{r PLSR with light, include=FALSE}
# How correlated are leaf-area and absorption profiles?
ProfileCorrelations <- data.frame(p=rep(NA,18),
                                  r=rep(NA,18))
for(i in 1:18){
  ProfileCorrelations$p[i] <- cor.test(x=CARBONO$LAI[i,10:60],y=CARBONO$Light_abs[i,10:60])$p.value
  ProfileCorrelations$r[i] <- cor.test(x=CARBONO$LAI[i,10:60],y=CARBONO$Light_abs[i,10:60])$estimate^2
}

## Predict ANPP from leaf-area profiles using a partial least squares analysis

# Create data frames to store result from leaf-area profile PLS models to predict litter production, wood production, and total ANPP
  LitterRpt_tra <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)
  WoodRpt_tra <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)
  TotalRpt_tra <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)

# Create data frames to store result from leaf-area profile PLS models to predict litter production, wood production, and total ANPP
  LitterRpt_abs <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)
  WoodRpt_abs <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)
  TotalRpt_abs <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)
  
# Create data frames to store predicted (leaf-area profile PLS) values of litter production, wood production, and total ANPP for validation plots  
  LitterValuesPredicted_tra <- matrix(nrow=testsize, ncol=niter, data=NA)
  WoodValuesPredicted_tra <- matrix(nrow=testsize, ncol=niter, data=NA)
  TotalValuesPredicted_tra <- matrix(nrow=testsize, ncol=niter, data=NA)

# Create data frames to store predicted (leaf-area profile PLS) values of litter production, wood production, and total ANPP for validation plots  
  LitterValuesPredicted_abs <- matrix(nrow=testsize, ncol=niter, data=NA)
  WoodValuesPredicted_abs <- matrix(nrow=testsize, ncol=niter, data=NA)
  TotalValuesPredicted_abs <- matrix(nrow=testsize, ncol=niter, data=NA)
  

# For each sample, predict litter production, wood production, and total ANPP using three methods.  
for(i in 1:niter){
  # Split data into subsets for model training (LAI train) and model testing (LAI test)
    LAItrain <- CARBONO[SampleList[i,],]
    LAItest <- CARBONO[-SampleList[i,],]

  # Fit PLS models to predict litter production, wood production, and total ANPP from leaf-area profiles
    Litter.PLS_tra <- pls::plsr(Litter~Light_tra, ncomp=3, data=LAItrain, validation="LOO")
      LitterRpt_tra[i,"fitx"] <- sum(pls::explvar(Litter.PLS_tra))
      LitterRpt_tra[i,"fity"] <- 100*drop(pls::R2(Litter.PLS_tra, estimate = "train",intercept = FALSE)$val)[3]
    Wood.PLS_tra <- pls::plsr(Wood~Light_tra, ncomp=3, data=LAItrain, validation="LOO")
      WoodRpt_tra[i,"fitx"] <- sum(pls::explvar(Wood.PLS_tra))
      WoodRpt_tra[i,"fity"] <- 100*drop(pls::R2(Wood.PLS_tra, estimate = "train",intercept = FALSE)$val)[3]
    Total.PLS_tra <- pls::plsr(ANPP~Light_tra, ncomp=3, data=LAItrain, validation="LOO")
      TotalRpt_tra[i,"fitx"] <- sum(pls::explvar(Total.PLS_tra))
      TotalRpt_tra[i,"fity"] <- 100*drop(pls::R2(Total.PLS_tra, estimate = "train",intercept = FALSE)$val)[3]
      
  # Fit PLS models to predict litter production, wood production, and total ANPP from leaf-area profiles
    Litter.PLS_abs <- pls::plsr(Litter~Light_abs, ncomp=3, data=LAItrain, validation="LOO")
      LitterRpt_abs[i,"fitx"] <- sum(pls::explvar(Litter.PLS_abs))
      LitterRpt_abs[i,"fity"] <- 100*drop(pls::R2(Litter.PLS_abs, estimate = "train",intercept = FALSE)$val)[3]
    Wood.PLS_abs <- pls::plsr(Wood~Light_abs, ncomp=3, data=LAItrain, validation="LOO")
      WoodRpt_abs[i,"fitx"] <- sum(pls::explvar(Wood.PLS_abs))
      WoodRpt_abs[i,"fity"] <- 100*drop(pls::R2(Wood.PLS_abs, estimate = "train",intercept = FALSE)$val)[3]
    Total.PLS_abs <- pls::plsr(ANPP~Light_abs, ncomp=3, data=LAItrain, validation="LOO")
      TotalRpt_abs[i,"fitx"] <- sum(pls::explvar(Total.PLS_abs))
      TotalRpt_abs[i,"fity"] <- 100*drop(pls::R2(Total.PLS_abs, estimate = "train",intercept = FALSE)$val)[3]
    
  # Record observed litter production values for the validation subset, and predict litter production values for each model
    LitterValuesPredicted_tra[,i] <- predict(Litter.PLS_tra, ncomp=3, newdata=LAItest)
    LitterValuesPredicted_abs[,i] <- predict(Litter.PLS_abs, ncomp=3, newdata=LAItest)
    
  # Record observed wood production values for the validation subset, and predict litter production values for each model  
    WoodValuesPredicted_tra[,i] <- predict(Wood.PLS_tra, ncomp=3, newdata=LAItest)
    WoodValuesPredicted_abs[,i] <- predict(Wood.PLS_abs, ncomp=3, newdata=LAItest)
  
  # Record observed total ANPP values for the validation subset, and predict litter production values for each model
    TotalValuesPredicted_tra[,i] <- predict(Total.PLS_tra, ncomp=3, newdata=LAItest)
    TotalValuesPredicted_abs[,i] <- predict(Total.PLS_abs, ncomp=3, newdata=LAItest)
   
  # Fit a pearson correlation between predicted and observed litter production using leaf-area profiles, and record p-value.
  # Fit a model of predicted and observed litter production using leaf-area profiles, and record intercept, slope, and r-squared values.
    # Deming regression instead
    LitterDeming <- mcr::mcreg(LitterValuesPredicted_tra[,i],LAItest$Litter,method.reg="Deming",error.ratio=1,method.ci="analytical")
    LitterRpt_tra[i,1] <- cor.test(x=LitterValuesPredicted_tra[,i], y=LAItest$Litter, method="pearson")$p.value
    LitterRpt_tra[i,2] <- mcr::getCoefficients(LitterDeming)[1,1]
    LitterRpt_tra[i,3] <- mcr::getCoefficients(LitterDeming)[2,1]
    LitterRpt_tra[i,4] <- cor.test(x=LitterValuesPredicted_tra[,i], y=LAItest$Litter, method="pearson")$estimate^2
    
    LitterDeming <- mcr::mcreg(LitterValuesPredicted_abs[,i],LAItest$Litter,method.reg="Deming",error.ratio=1,method.ci="analytical")
    LitterRpt_abs[i,1] <- cor.test(x=LitterValuesPredicted_abs[,i], y=LAItest$Litter, method="pearson")$p.value
    LitterRpt_abs[i,2] <- mcr::getCoefficients(LitterDeming)[1,1]
    LitterRpt_abs[i,3] <- mcr::getCoefficients(LitterDeming)[2,1]
    LitterRpt_abs[i,4] <- cor.test(x=LitterValuesPredicted_abs[,i], y=LAItest$Litter, method="pearson")$estimate^2
    
  # Fit a pearson correlation between predicted and observed wood production using leaf-area profiles, and record p-value.
  # Fit a model of predicted and observed wood production using leaf-area profiles, and record intercept, slope, and r-squared values.   
    # Deming regression
    WoodDeming <- mcr::mcreg(WoodValuesPredicted_tra[,i],LAItest$Wood,method.reg="Deming",error.ratio=1,method.ci="analytical")
    WoodRpt_tra[i,1] <- cor.test(x=WoodValuesPredicted_tra[,i], y=LAItest$Wood, method="pearson")$p.value
    WoodRpt_tra[i,2] <- mcr::getCoefficients(WoodDeming)[1,1]
    WoodRpt_tra[i,3] <- mcr::getCoefficients(WoodDeming)[2,1]
    WoodRpt_tra[i,4] <- cor.test(x=WoodValuesPredicted_tra[,i], y=LAItest$Wood, method="pearson")$estimate^2
    
    WoodDeming <- mcr::mcreg(WoodValuesPredicted_abs[,i],LAItest$Wood,method.reg="Deming",error.ratio=1,method.ci="analytical")
    WoodRpt_abs[i,1] <- cor.test(x=WoodValuesPredicted_abs[,i], y=LAItest$Wood, method="pearson")$p.value
    WoodRpt_abs[i,2] <- mcr::getCoefficients(WoodDeming)[1,1]
    WoodRpt_abs[i,3] <- mcr::getCoefficients(WoodDeming)[2,1]
    WoodRpt_abs[i,4] <- cor.test(x=WoodValuesPredicted_abs[,i], y=LAItest$Wood, method="pearson")$estimate^2
  
  # Fit a pearson correlation between predicted and observed total ANPP using leaf-area profiles, and record p-value.
  # Fit a model of predicted and observed total ANPP using leaf-area profiles, and record intercept, slope, and r-squared values.   
    # Deming regression instead
    TotalDeming <- mcr::mcreg(TotalValuesPredicted_tra[,i],LAItest$ANPP,method.reg="Deming",error.ratio=1,method.ci="analytical")
    TotalRpt_tra[i,1] <- cor.test(x=TotalValuesPredicted_tra[,i], y=LAItest$ANPP, method="pearson")$p.value
    TotalRpt_tra[i,2] <- mcr::getCoefficients(TotalDeming)[1,1]
    TotalRpt_tra[i,3] <- mcr::getCoefficients(TotalDeming)[2,1]
    TotalRpt_tra[i,4] <- cor.test(x=TotalValuesPredicted_tra[,i], y=LAItest$ANPP, method="pearson")$estimate^2
    
    TotalDeming <- mcr::mcreg(TotalValuesPredicted_abs[,i],LAItest$ANPP,method.reg="Deming",error.ratio=1,method.ci="analytical")
    TotalRpt_abs[i,1] <- cor.test(x=TotalValuesPredicted_abs[,i], y=LAItest$ANPP, method="pearson")$p.value
    TotalRpt_abs[i,2] <- mcr::getCoefficients(TotalDeming)[1,1]
    TotalRpt_abs[i,3] <- mcr::getCoefficients(TotalDeming)[2,1]
    TotalRpt_abs[i,4] <- cor.test(x=TotalValuesPredicted_abs[,i], y=LAItest$ANPP, method="pearson")$estimate^2
}

# Create data frames to store summary results from repeated sampling for leaf-area profile models.    
  LitterQuantiles_tra <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  WoodQuantiles_tra <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  TotalQuantiles_tra <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  
  LitterQuantiles_abs <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  WoodQuantiles_abs <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  TotalQuantiles_abs <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)

# Loop through each column (p-value, intercenpt, slope, and r-squared), compute summary statistics.
  for(i in 1:4){
    LitterQuantiles_tra[i,c("lower","median","upper")] <- quantile(x=LitterRpt_tra[,i], probs=c(0.025,0.5,0.975))
    LitterQuantiles_tra[i,c("mean")] <- mean(LitterRpt_tra[,i])
    WoodQuantiles_tra[i,c("lower","median","upper")] <- quantile(x=WoodRpt_tra[,i], probs=c(0.025,0.5,0.975))
    WoodQuantiles_tra[i,c("mean")] <- mean(WoodRpt_tra[,i])
    TotalQuantiles_tra[i,c("lower","median","upper")] <- quantile(x=TotalRpt_tra[,i], probs=c(0.025,0.5,0.975))
    TotalQuantiles_tra[i,c("mean")] <- mean(TotalRpt_tra[,i])
    
    LitterQuantiles_abs[i,c("lower","median","upper")] <- quantile(x=LitterRpt_abs[,i], probs=c(0.025,0.5,0.975))
    LitterQuantiles_abs[i,c("mean")] <- mean(LitterRpt_abs[,i])
    WoodQuantiles_abs[i,c("lower","median","upper")] <- quantile(x=WoodRpt_abs[,i], probs=c(0.025,0.5,0.975))
    WoodQuantiles_abs[i,c("mean")] <- mean(WoodRpt_abs[,i])
    TotalQuantiles_abs[i,c("lower","median","upper")] <- quantile(x=TotalRpt_abs[,i], probs=c(0.025,0.5,0.975))
    TotalQuantiles_abs[i,c("mean")] <- mean(TotalRpt_abs[,i])
  }

  # Calculate component loadings values for leaf-area profile PLS models

  # Create matrices to store total ANPP loadings for the first 3 components, and total combined weights
  TotalC1Loadings_tra <- matrix(nrow = 60, ncol=niter, data=NA)
  TotalC2Loadings_tra <- matrix(nrow = 60, ncol=niter, data=NA)
  TotalC3Loadings_tra <- matrix(nrow = 60, ncol=niter, data=NA)
  TotalWeights_tra <- matrix(nrow = 60, ncol=niter, data=NA)
  
  TotalC1Loadings_abs <- matrix(nrow = 60, ncol=niter, data=NA)
  TotalC2Loadings_abs <- matrix(nrow = 60, ncol=niter, data=NA)
  TotalC3Loadings_abs <- matrix(nrow = 60, ncol=niter, data=NA)
  TotalWeights_abs <- matrix(nrow = 60, ncol=niter, data=NA)
  
  # Record the loading values for each random sample PLS
  for(i in 1:niter){
    # Fit PLS model
      LAItrain <- CARBONO[SampleList[i,],]
      LAItest <- CARBONO[-SampleList[i,],]
      Total.PLS_tra <- pls::plsr(ANPP~Light_tra, ncomp=3, data=LAItrain, validation="LOO")
      Total.PLS_abs <- pls::plsr(ANPP~Light_abs, ncomp=3, data=LAItrain, validation="LOO")
      
    # Record first three component values
      TotalC1Loadings_tra[,i] <- Total.PLS_tra$loadings[,1]
      TotalC2Loadings_tra[,i] <- Total.PLS_tra$loadings[,2]
      TotalC3Loadings_tra[,i] <- Total.PLS_tra$loadings[,3]
      
      TotalC1Loadings_abs[,i] <- Total.PLS_abs$loadings[,1]
      TotalC2Loadings_abs[,i] <- Total.PLS_abs$loadings[,2]
      TotalC3Loadings_abs[,i] <- Total.PLS_abs$loadings[,3]
    
    # Calculate the proportion of variation explained by each component
      Comp1Var <- 100*drop(pls::R2(Total.PLS, estimate = "train",intercept = FALSE)$val)[1]
      Comp2Var <- 100*drop(pls::R2(Total.PLS, estimate = "train",intercept = FALSE)$val)[2]-Comp1Var
      Comp3Var <- 100*drop(pls::R2(Total.PLS, estimate = "train",intercept = FALSE)$val)[3]-Comp1Var-Comp2Var
        # Calculate the combined loadings, weighted by that amoung of variation explained by each component 
        TotalWeights_tra[,i] <- Total.PLS_tra$loadings[,1]*Comp1Var + Total.PLS_tra$loadings[,2]*Comp2Var + Total.PLS_tra$loadings[,3]*Comp3Var
        
      Comp1Var <- 100*drop(pls::R2(Total.PLS, estimate = "train",intercept = FALSE)$val)[1]
      Comp2Var <- 100*drop(pls::R2(Total.PLS, estimate = "train",intercept = FALSE)$val)[2]-Comp1Var
      Comp3Var <- 100*drop(pls::R2(Total.PLS, estimate = "train",intercept = FALSE)$val)[3]-Comp1Var-Comp2Var
        # Calculate the combined loadings, weighted by that amoung of variation explained by each component 
        TotalWeights_abs[,i] <- Total.PLS_abs$loadings[,1]*Comp1Var + Total.PLS_abs$loadings[,2]*Comp2Var + Total.PLS_abs$loadings[,3]*Comp3Var        
  }
  
  # Create data frames to store loading summary statistics
    TotalC1LoadingsSummary_tra <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    TotalC2LoadingsSummary_tra <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    TotalC3LoadingsSummary_tra <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    TotalWeightsSummary_tra <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    
    TotalC1LoadingsSummary_abs <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    TotalC2LoadingsSummary_abs <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    TotalC3LoadingsSummary_abs <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    TotalWeightsSummary_abs <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    
  # Calculate summary statistics
    for(i in 1:60){
      TotalC1LoadingsSummary_tra[i,c('min','median','max')] <- quantile(TotalC1Loadings_tra[i,], probs=c(0.025,0.5,0.975))
        TotalC1LoadingsSummary_tra[i,'mean'] <- mean(TotalC1Loadings_tra[i,])
      TotalC2LoadingsSummary_tra[i,c('min','median','max')] <- quantile(TotalC2Loadings_tra[i,], probs=c(0.025,0.5,0.975))
        TotalC2LoadingsSummary_tra[i,'mean'] <- mean(TotalC2Loadings_tra[i,])
      TotalC3LoadingsSummary_tra[i,c('min','median','max')] <- quantile(TotalC3Loadings_tra[i,], probs=c(0.025,0.5,0.975))
        TotalC3LoadingsSummary_tra[i,'mean'] <- mean(TotalC3Loadings_tra[i,])
      TotalWeightsSummary_tra[i,c('min','median','max')] <- quantile(TotalWeights_tra[i,], probs=c(0.025,0.5,0.975))
        TotalWeightsSummary_tra[i,'mean'] <- mean(TotalWeights_tra[i,])
        
      TotalC1LoadingsSummary_abs[i,c('min','median','max')] <- quantile(TotalC1Loadings_abs[i,], probs=c(0.025,0.5,0.975))
        TotalC1LoadingsSummary_abs[i,'mean'] <- mean(TotalC1Loadings_abs[i,])
      TotalC2LoadingsSummary_abs[i,c('min','median','max')] <- quantile(TotalC2Loadings_abs[i,], probs=c(0.025,0.5,0.975))
        TotalC2LoadingsSummary_abs[i,'mean'] <- mean(TotalC2Loadings_abs[i,])
      TotalC3LoadingsSummary_abs[i,c('min','median','max')] <- quantile(TotalC3Loadings_abs[i,], probs=c(0.025,0.5,0.975))
        TotalC3LoadingsSummary_abs[i,'mean'] <- mean(TotalC3Loadings_abs[i,])
      TotalWeightsSummary_abs[i,c('min','median','max')] <- quantile(TotalWeights_abs[i,], probs=c(0.025,0.5,0.975))
        TotalWeightsSummary_abs[i,'mean'] <- mean(TotalWeights_abs[i,])  
    }

  LitterC1Loadings_tra <- matrix(nrow = 60, ncol=niter, data=NA)
  LitterC2Loadings_tra <- matrix(nrow = 60, ncol=niter, data=NA)
  LitterC3Loadings_tra <- matrix(nrow = 60, ncol=niter, data=NA)
  LitterWeights_tra <- matrix(nrow = 60, ncol=niter, data=NA)
  
  LitterC1Loadings_abs <- matrix(nrow = 60, ncol=niter, data=NA)
  LitterC2Loadings_abs <- matrix(nrow = 60, ncol=niter, data=NA)
  LitterC3Loadings_abs <- matrix(nrow = 60, ncol=niter, data=NA)
  LitterWeights_abs <- matrix(nrow = 60, ncol=niter, data=NA)
  
  # Record the loading values for each random sample PLS
  for(i in 1:niter){
    # Fit PLS model
      LAItrain <- CARBONO[SampleList[i,],]
      LAItest <- CARBONO[-SampleList[i,],]
      Litter.PLS_tra <- pls::plsr(Litter~Light_tra, ncomp=3, data=LAItrain, validation="LOO")
      Litter.PLS_abs <- pls::plsr(Litter~Light_abs, ncomp=3, data=LAItrain, validation="LOO")
      
    # Record first three component values
      LitterC1Loadings_tra[,i] <- Litter.PLS_tra$loadings[,1]
      LitterC2Loadings_tra[,i] <- Litter.PLS_tra$loadings[,2]
      LitterC3Loadings_tra[,i] <- Litter.PLS_tra$loadings[,3]
      
      LitterC1Loadings_abs[,i] <- Litter.PLS_abs$loadings[,1]
      LitterC2Loadings_abs[,i] <- Litter.PLS_abs$loadings[,2]
      LitterC3Loadings_abs[,i] <- Litter.PLS_abs$loadings[,3]
    
    # Calculate the proportion of variation explained by each component
      Comp1Var <- 100*drop(pls::R2(Litter.PLS, estimate = "train",intercept = FALSE)$val)[1]
      Comp2Var <- 100*drop(pls::R2(Litter.PLS, estimate = "train",intercept = FALSE)$val)[2]-Comp1Var
      Comp3Var <- 100*drop(pls::R2(Litter.PLS, estimate = "train",intercept = FALSE)$val)[3]-Comp1Var-Comp2Var
        # Calculate the combined loadings, weighted by that amoung of variation explained by each component 
        LitterWeights_tra[,i] <- Litter.PLS_tra$loadings[,1]*Comp1Var + Litter.PLS_tra$loadings[,2]*Comp2Var + Litter.PLS_tra$loadings[,3]*Comp3Var
        
      Comp1Var <- 100*drop(pls::R2(Litter.PLS, estimate = "train",intercept = FALSE)$val)[1]
      Comp2Var <- 100*drop(pls::R2(Litter.PLS, estimate = "train",intercept = FALSE)$val)[2]-Comp1Var
      Comp3Var <- 100*drop(pls::R2(Litter.PLS, estimate = "train",intercept = FALSE)$val)[3]-Comp1Var-Comp2Var
        # Calculate the combined loadings, weighted by that amoung of variation explained by each component 
        LitterWeights_abs[,i] <- Litter.PLS_abs$loadings[,1]*Comp1Var + Litter.PLS_abs$loadings[,2]*Comp2Var + Litter.PLS_abs$loadings[,3]*Comp3Var        
  }
  
  # Create data frames to store loading summary statistics
    LitterC1LoadingsSummary_tra <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    LitterC2LoadingsSummary_tra <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    LitterC3LoadingsSummary_tra <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    LitterWeightsSummary_tra <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    
    LitterC1LoadingsSummary_abs <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    LitterC2LoadingsSummary_abs <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    LitterC3LoadingsSummary_abs <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    LitterWeightsSummary_abs <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    
  # Calculate summary statistics
    for(i in 1:60){
      LitterC1LoadingsSummary_tra[i,c('min','median','max')] <- quantile(LitterC1Loadings_tra[i,], probs=c(0.025,0.5,0.975))
        LitterC1LoadingsSummary_tra[i,'mean'] <- mean(LitterC1Loadings_tra[i,])
      LitterC2LoadingsSummary_tra[i,c('min','median','max')] <- quantile(LitterC2Loadings_tra[i,], probs=c(0.025,0.5,0.975))
        LitterC2LoadingsSummary_tra[i,'mean'] <- mean(LitterC2Loadings_tra[i,])
      LitterC3LoadingsSummary_tra[i,c('min','median','max')] <- quantile(LitterC3Loadings_tra[i,], probs=c(0.025,0.5,0.975))
        LitterC3LoadingsSummary_tra[i,'mean'] <- mean(LitterC3Loadings_tra[i,])
      LitterWeightsSummary_tra[i,c('min','median','max')] <- quantile(LitterWeights_tra[i,], probs=c(0.025,0.5,0.975))
        LitterWeightsSummary_tra[i,'mean'] <- mean(LitterWeights_tra[i,])
        
      LitterC1LoadingsSummary_abs[i,c('min','median','max')] <- quantile(LitterC1Loadings_abs[i,], probs=c(0.025,0.5,0.975))
        LitterC1LoadingsSummary_abs[i,'mean'] <- mean(LitterC1Loadings_abs[i,])
      LitterC2LoadingsSummary_abs[i,c('min','median','max')] <- quantile(LitterC2Loadings_abs[i,], probs=c(0.025,0.5,0.975))
        LitterC2LoadingsSummary_abs[i,'mean'] <- mean(LitterC2Loadings_abs[i,])
      LitterC3LoadingsSummary_abs[i,c('min','median','max')] <- quantile(LitterC3Loadings_abs[i,], probs=c(0.025,0.5,0.975))
        LitterC3LoadingsSummary_abs[i,'mean'] <- mean(LitterC3Loadings_abs[i,])
      LitterWeightsSummary_abs[i,c('min','median','max')] <- quantile(LitterWeights_abs[i,], probs=c(0.025,0.5,0.975))
        LitterWeightsSummary_abs[i,'mean'] <- mean(LitterWeights_abs[i,])  
    }
    
  WoodC1Loadings_tra <- matrix(nrow = 60, ncol=niter, data=NA)
  WoodC2Loadings_tra <- matrix(nrow = 60, ncol=niter, data=NA)
  WoodC3Loadings_tra <- matrix(nrow = 60, ncol=niter, data=NA)
  WoodWeights_tra <- matrix(nrow = 60, ncol=niter, data=NA)
  
  WoodC1Loadings_abs <- matrix(nrow = 60, ncol=niter, data=NA)
  WoodC2Loadings_abs <- matrix(nrow = 60, ncol=niter, data=NA)
  WoodC3Loadings_abs <- matrix(nrow = 60, ncol=niter, data=NA)
  WoodWeights_abs <- matrix(nrow = 60, ncol=niter, data=NA)
  
  # Record the loading values for each random sample PLS
  for(i in 1:niter){
    # Fit PLS model
      LAItrain <- CARBONO[SampleList[i,],]
      LAItest <- CARBONO[-SampleList[i,],]
      Wood.PLS_tra <- pls::plsr(Wood~Light_tra, ncomp=3, data=LAItrain, validation="LOO")
      Wood.PLS_abs <- pls::plsr(Wood~Light_abs, ncomp=3, data=LAItrain, validation="LOO")
      
    # Record first three component values
      WoodC1Loadings_tra[,i] <- Wood.PLS_tra$loadings[,1]
      WoodC2Loadings_tra[,i] <- Wood.PLS_tra$loadings[,2]
      WoodC3Loadings_tra[,i] <- Wood.PLS_tra$loadings[,3]
      
      WoodC1Loadings_abs[,i] <- Wood.PLS_abs$loadings[,1]
      WoodC2Loadings_abs[,i] <- Wood.PLS_abs$loadings[,2]
      WoodC3Loadings_abs[,i] <- Wood.PLS_abs$loadings[,3]
    
    # Calculate the proportion of variation explained by each component
      Comp1Var <- 100*drop(pls::R2(Wood.PLS_tra, estimate = "train",intercept = FALSE)$val)[1]
      Comp2Var <- 100*drop(pls::R2(Wood.PLS_tra, estimate = "train",intercept = FALSE)$val)[2]-Comp1Var
      Comp3Var <- 100*drop(pls::R2(Wood.PLS_tra, estimate = "train",intercept = FALSE)$val)[3]-Comp1Var-Comp2Var
        # Calculate the combined loadings, weighted by that amoung of variation explained by each component 
        WoodWeights_tra[,i] <- Wood.PLS_tra$loadings[,1]*Comp1Var + Wood.PLS_tra$loadings[,2]*Comp2Var + Wood.PLS_tra$loadings[,3]*Comp3Var
        
      Comp1Var <- 100*drop(pls::R2(Wood.PLS_abs, estimate = "train",intercept = FALSE)$val)[1]
      Comp2Var <- 100*drop(pls::R2(Wood.PLS_abs, estimate = "train",intercept = FALSE)$val)[2]-Comp1Var
      Comp3Var <- 100*drop(pls::R2(Wood.PLS_abs, estimate = "train",intercept = FALSE)$val)[3]-Comp1Var-Comp2Var
        # Calculate the combined loadings, weighted by that amoung of variation explained by each component 
        WoodWeights_abs[,i] <- Wood.PLS_abs$loadings[,1]*Comp1Var + Wood.PLS_abs$loadings[,2]*Comp2Var + Wood.PLS_abs$loadings[,3]*Comp3Var        
  }
  
  # Create data frames to store loading summary statistics
    WoodC1LoadingsSummary_tra <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    WoodC2LoadingsSummary_tra <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    WoodC3LoadingsSummary_tra <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    WoodWeightsSummary_tra <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    
    WoodC1LoadingsSummary_abs <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    WoodC2LoadingsSummary_abs <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    WoodC3LoadingsSummary_abs <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    WoodWeightsSummary_abs <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
    
  # Calculate summary statistics
    for(i in 1:60){
      WoodC1LoadingsSummary_tra[i,c('min','median','max')] <- quantile(WoodC1Loadings_tra[i,], probs=c(0.025,0.5,0.975))
        WoodC1LoadingsSummary_tra[i,'mean'] <- mean(WoodC1Loadings_tra[i,])
      WoodC2LoadingsSummary_tra[i,c('min','median','max')] <- quantile(WoodC2Loadings_tra[i,], probs=c(0.025,0.5,0.975))
        WoodC2LoadingsSummary_tra[i,'mean'] <- mean(WoodC2Loadings_tra[i,])
      WoodC3LoadingsSummary_tra[i,c('min','median','max')] <- quantile(WoodC3Loadings_tra[i,], probs=c(0.025,0.5,0.975))
        WoodC3LoadingsSummary_tra[i,'mean'] <- mean(WoodC3Loadings_tra[i,])
      WoodWeightsSummary_tra[i,c('min','median','max')] <- quantile(WoodWeights_tra[i,], probs=c(0.025,0.5,0.975))
        WoodWeightsSummary_tra[i,'mean'] <- mean(WoodWeights_tra[i,])
        
      WoodC1LoadingsSummary_abs[i,c('min','median','max')] <- quantile(WoodC1Loadings_abs[i,], probs=c(0.025,0.5,0.975))
        WoodC1LoadingsSummary_abs[i,'mean'] <- mean(WoodC1Loadings_abs[i,])
      WoodC2LoadingsSummary_abs[i,c('min','median','max')] <- quantile(WoodC2Loadings_abs[i,], probs=c(0.025,0.5,0.975))
        WoodC2LoadingsSummary_abs[i,'mean'] <- mean(WoodC2Loadings_abs[i,])
      WoodC3LoadingsSummary_abs[i,c('min','median','max')] <- quantile(WoodC3Loadings_abs[i,], probs=c(0.025,0.5,0.975))
        WoodC3LoadingsSummary_abs[i,'mean'] <- mean(WoodC3Loadings_abs[i,])
      WoodWeightsSummary_abs[i,c('min','median','max')] <- quantile(WoodWeights_abs[i,], probs=c(0.025,0.5,0.975))
        WoodWeightsSummary_abs[i,'mean'] <- mean(WoodWeights_abs[i,])  
    }
    
```

```{r PLSR with light + LAI, include=FALSE}

# Create data frames to store result from leaf-area profile PLS models to predict litter production, wood production, and total ANPP
  LitterRpt_lai_tra <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)
  WoodRpt_lai_tra <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)
  TotalRpt_lai_tra <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)

# Create data frames to store result from leaf-area profile PLS models to predict litter production, wood production, and total ANPP
  LitterRpt_lai_abs <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)
  WoodRpt_lai_abs <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)
  TotalRpt_lai_abs <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)

# Create data frames to store predicted (leaf-area profile PLS) values of litter production, wood production, and total ANPP for validation plots  
  LitterValuesPredicted_lai_tra <- matrix(nrow=testsize, ncol=niter, data=NA)
  WoodValuesPredicted_lai_tra <- matrix(nrow=testsize, ncol=niter, data=NA)
  TotalValuesPredicted_lai_tra <- matrix(nrow=testsize, ncol=niter, data=NA)

# Create data frames to store predicted (leaf-area profile PLS) values of litter production, wood production, and total ANPP for validation plots  
  LitterValuesPredicted_lai_abs <- matrix(nrow=testsize, ncol=niter, data=NA)
  WoodValuesPredicted_lai_abs <- matrix(nrow=testsize, ncol=niter, data=NA)
  TotalValuesPredicted_lai_abs <- matrix(nrow=testsize, ncol=niter, data=NA)


# For each sample, predict litter production, wood production, and total ANPP using three methods.  
for(i in 1:niter){
  # Split data into subsets for model training (LAI train) and model testing (LAI test)
    LAItrain <- CARBONO[SampleList[i,],]
    LAItest <- CARBONO[-SampleList[i,],]

  
  # Fit PLS models to predict litter production, wood production, and total ANPP from leaf-area profiles
    Litter.PLS_lai_tra <- pls::plsr(Litter~LAI+Light_tra, ncomp=3, data=LAItrain, validation="LOO")
      LitterRpt_lai_tra[i,"fitx"] <- sum(pls::explvar(Litter.PLS_lai_tra))
      LitterRpt_lai_tra[i,"fity"] <- 100*drop(pls::R2(Litter.PLS_lai_tra, estimate = "train",intercept = FALSE)$val)[3]
    Wood.PLS_lai_tra <- pls::plsr(Wood~LAI+Light_tra, ncomp=3, data=LAItrain, validation="LOO")
      WoodRpt_lai_tra[i,"fitx"] <- sum(pls::explvar(Wood.PLS_lai_tra))
      WoodRpt_lai_tra[i,"fity"] <- 100*drop(pls::R2(Wood.PLS_lai_tra, estimate = "train",intercept = FALSE)$val)[3]
    Total.PLS_lai_tra <- pls::plsr(ANPP~LAI+Light_tra, ncomp=3, data=LAItrain, validation="LOO")
      TotalRpt_lai_tra[i,"fitx"] <- sum(pls::explvar(Total.PLS_lai_tra))
      TotalRpt_lai_tra[i,"fity"] <- 100*drop(pls::R2(Total.PLS_lai_tra, estimate = "train",intercept = FALSE)$val)[3]
      
  # Fit PLS models to predict litter production, wood production, and total ANPP from leaf-area profiles
    Litter.PLS_lai_abs <- pls::plsr(Litter~LAI+Light_abs, ncomp=3, data=LAItrain, validation="LOO")
      LitterRpt_lai_abs[i,"fitx"] <- sum(pls::explvar(Litter.PLS_lai_abs))
      LitterRpt_lai_abs[i,"fity"] <- 100*drop(pls::R2(Litter.PLS_lai_abs, estimate = "train",intercept = FALSE)$val)[3]
    Wood.PLS_lai_abs <- pls::plsr(Wood~LAI+Light_abs, ncomp=3, data=LAItrain, validation="LOO")
      WoodRpt_lai_abs[i,"fitx"] <- sum(pls::explvar(Wood.PLS_lai_abs))
      WoodRpt_lai_abs[i,"fity"] <- 100*drop(pls::R2(Wood.PLS_lai_abs, estimate = "train",intercept = FALSE)$val)[3]
    Total.PLS_lai_abs <- pls::plsr(ANPP~LAI+Light_abs, ncomp=3, data=LAItrain, validation="LOO")
      TotalRpt_lai_abs[i,"fitx"] <- sum(pls::explvar(Total.PLS_lai_abs))
      TotalRpt_lai_abs[i,"fity"] <- 100*drop(pls::R2(Total.PLS_lai_abs, estimate = "train",intercept = FALSE)$val)[3]
    
  # Record observed litter production values for the validation subset, and predict litter production values for each model
    LitterValuesPredicted_lai_tra[,i] <- predict(Litter.PLS_lai_tra, ncomp=3, newdata=LAItest)
    LitterValuesPredicted_lai_abs[,i] <- predict(Litter.PLS_lai_abs, ncomp=3, newdata=LAItest)
    
  # Record observed wood production values for the validation subset, and predict litter production values for each model  
    WoodValuesPredicted_lai_tra[,i] <- predict(Wood.PLS_lai_tra, ncomp=3, newdata=LAItest)
    WoodValuesPredicted_lai_abs[,i] <- predict(Wood.PLS_lai_abs, ncomp=3, newdata=LAItest)
    
  # Record observed total ANPP values for the validation subset, and predict litter production values for each model
    TotalValuesPredicted_lai_tra[,i] <- predict(Total.PLS_lai_tra, ncomp=3, newdata=LAItest)
    TotalValuesPredicted_lai_abs[,i] <- predict(Total.PLS_lai_abs, ncomp=3, newdata=LAItest)    
   
  # Fit a pearson correlation between predicted and observed litter production using leaf-area profiles, and record p-value.
  # Fit a model of predicted and observed litter production using leaf-area profiles, and record intercept, slope, and r-squared values.
    # Deming regression
    LitterDeming <- mcr::mcreg(LitterValuesPredicted_lai_tra[,i],LAItest$Litter,method.reg="Deming",error.ratio=1,method.ci="analytical")
    LitterRpt_lai_tra[i,1] <- cor.test(x=LitterValuesPredicted_lai_tra[,i], y=LAItest$Litter, method="pearson")$p.value
    LitterRpt_lai_tra[i,2] <- mcr::getCoefficients(LitterDeming)[1,1]
    LitterRpt_lai_tra[i,3] <- mcr::getCoefficients(LitterDeming)[2,1]
    LitterRpt_lai_tra[i,4] <- cor.test(x=LitterValuesPredicted_lai_tra[,i], y=LAItest$Litter, method="pearson")$estimate^2
    
    LitterDeming <- mcr::mcreg(LitterValuesPredicted_lai_abs[,i],LAItest$Litter,method.reg="Deming",error.ratio=1,method.ci="analytical")
    LitterRpt_lai_abs[i,1] <- cor.test(x=LitterValuesPredicted_lai_abs[,i], y=LAItest$Litter, method="pearson")$p.value
    LitterRpt_lai_abs[i,2] <- mcr::getCoefficients(LitterDeming)[1,1]
    LitterRpt_lai_abs[i,3] <- mcr::getCoefficients(LitterDeming)[2,1]
    LitterRpt_lai_abs[i,4] <- cor.test(x=LitterValuesPredicted_lai_abs[,i], y=LAItest$Litter, method="pearson")$estimate^2
    
  # Fit a pearson correlation between predicted and observed wood production using leaf-area profiles, and record p-value.
  # Fit a model of predicted and observed wood production using leaf-area profiles, and record intercept, slope, and r-squared values.       # Deming regression
    WoodDeming <- mcr::mcreg(WoodValuesPredicted_lai_tra[,i],LAItest$Wood,method.reg="Deming",error.ratio=1,method.ci="analytical")
    WoodRpt_lai_tra[i,1] <- cor.test(x=WoodValuesPredicted_lai_tra[,i], y=LAItest$Wood, method="pearson")$p.value
    WoodRpt_lai_tra[i,2] <- mcr::getCoefficients(WoodDeming)[1,1]
    WoodRpt_lai_tra[i,3] <- mcr::getCoefficients(WoodDeming)[2,1]
    WoodRpt_lai_tra[i,4] <- cor.test(x=WoodValuesPredicted_lai_tra[,i], y=LAItest$Wood, method="pearson")$estimate^2
    
    WoodDeming <- mcr::mcreg(WoodValuesPredicted_lai_abs[,i],LAItest$Wood,method.reg="Deming",error.ratio=1,method.ci="analytical")
    WoodRpt_lai_abs[i,1] <- cor.test(x=WoodValuesPredicted_lai_abs[,i], y=LAItest$Wood, method="pearson")$p.value
    WoodRpt_lai_abs[i,2] <- mcr::getCoefficients(WoodDeming)[1,1]
    WoodRpt_lai_abs[i,3] <- mcr::getCoefficients(WoodDeming)[2,1]
    WoodRpt_lai_abs[i,4] <- cor.test(x=WoodValuesPredicted_lai_abs[,i], y=LAItest$Wood, method="pearson")$estimate^2
  
  # Fit a pearson correlation between predicted and observed total ANPP using leaf-area profiles, and record p-value.
  # Fit a model of predicted and observed total ANPP using leaf-area profiles, and record intercept, slope, and r-squared values.   
    # Deming regression
    TotalDeming <- mcr::mcreg(TotalValuesPredicted_lai_tra[,i],LAItest$ANPP,method.reg="Deming",error.ratio=1,method.ci="analytical")
    TotalRpt_lai_tra[i,1] <- cor.test(x=TotalValuesPredicted_lai_tra[,i], y=LAItest$ANPP, method="pearson")$p.value
    TotalRpt_lai_tra[i,2] <- mcr::getCoefficients(TotalDeming)[1,1]
    TotalRpt_lai_tra[i,3] <- mcr::getCoefficients(TotalDeming)[2,1]
    TotalRpt_lai_tra[i,4] <- cor.test(x=TotalValuesPredicted_lai_tra[,i], y=LAItest$ANPP, method="pearson")$estimate^2
    
    TotalDeming <- mcr::mcreg(TotalValuesPredicted_lai_abs[,i],LAItest$ANPP,method.reg="Deming",error.ratio=1,method.ci="analytical")
    TotalRpt_lai_abs[i,1] <- cor.test(x=TotalValuesPredicted_lai_abs[,i], y=LAItest$ANPP, method="pearson")$p.value
    TotalRpt_lai_abs[i,2] <- mcr::getCoefficients(TotalDeming)[1,1]
    TotalRpt_lai_abs[i,3] <- mcr::getCoefficients(TotalDeming)[2,1]
    TotalRpt_lai_abs[i,4] <- cor.test(x=TotalValuesPredicted_lai_abs[,i], y=LAItest$ANPP, method="pearson")$estimate^2

}

# Create data frames to store summary results from repeated sampling for leaf-area profile models.    
  LitterQuantiles_lai_tra <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  WoodQuantiles_lai_tra <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  TotalQuantiles_lai_tra <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  
  LitterQuantiles_lai_abs <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  WoodQuantiles_lai_abs <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  TotalQuantiles_lai_abs <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)

# Loop through each column (p-value, intercenpt, slope, and r-squared), compute summary statistics.
  for(i in 1:4){
    LitterQuantiles_lai_tra[i,c("lower","median","upper")] <- quantile(x=LitterRpt_lai_tra[,i], probs=c(0.025,0.5,0.975))
    LitterQuantiles_lai_tra[i,c("mean")] <- mean(LitterRpt_lai_tra[,i])
    WoodQuantiles_lai_tra[i,c("lower","median","upper")] <- quantile(x=WoodRpt_lai_tra[,i], probs=c(0.025,0.5,0.975))
    WoodQuantiles_lai_tra[i,c("mean")] <- mean(WoodRpt_lai_tra[,i])
    TotalQuantiles_lai_tra[i,c("lower","median","upper")] <- quantile(x=TotalRpt_lai_tra[,i], probs=c(0.025,0.5,0.975))
    TotalQuantiles_lai_tra[i,c("mean")] <- mean(TotalRpt_lai_tra[,i])
    
    LitterQuantiles_lai_abs[i,c("lower","median","upper")] <- quantile(x=LitterRpt_lai_abs[,i], probs=c(0.025,0.5,0.975))
    LitterQuantiles_lai_abs[i,c("mean")] <- mean(LitterRpt_lai_abs[,i])
    WoodQuantiles_lai_abs[i,c("lower","median","upper")] <- quantile(x=WoodRpt_lai_abs[,i], probs=c(0.025,0.5,0.975))
    WoodQuantiles_lai_abs[i,c("mean")] <- mean(WoodRpt_lai_abs[,i])
    TotalQuantiles_lai_abs[i,c("lower","median","upper")] <- quantile(x=TotalRpt_lai_abs[,i], probs=c(0.025,0.5,0.975))
    TotalQuantiles_lai_abs[i,c("mean")] <- mean(TotalRpt_lai_abs[,i])
  }

```

```{r PLSR ANPP from separate models, include=FALSE}

## Predict ANPP from leaf-area profiles using a partial least squares analysis

# Create data frames to store result from leaf-area profile PLS models to predict litter production, wood production, and total ANPP
  TotalRpt_sep <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)

# Create data frames to store predicted (leaf-area profile PLS) values of litter production, wood production, and total ANPP for validation plots  
  TotalValuesPredicted_sep <- matrix(nrow=testsize, ncol=niter, data=NA)

# For each sample, predict litter production, wood production, and total ANPP using three methods.  
for(i in 1:niter){
  # Split data into subsets for model training (LAI train) and model testing (LAI test)
    LAItrain <- CARBONO[SampleList[i,],]
    LAItest <- CARBONO[-SampleList[i,],]

  # Fit PLS models to predict litter production, wood production, and total ANPP from leaf-area profiles
    Litter.PLS <- pls::plsr(Litter~LAI, ncomp=3, data=LAItrain, validation="LOO")
    Wood.PLS <- pls::plsr(Wood~LAI, ncomp=3, data=LAItrain, validation="LOO")

  # Record observed litter production values for the validation subset, and predict litter production values for each model
    LitterValuesPredicted_i <- predict(Litter.PLS, ncomp=3, newdata=LAItest)

  # Record observed wood production values for the validation subset, and predict litter production values for each model
    WoodValuesPredicted_i <- predict(Wood.PLS, ncomp=3, newdata=LAItest)

  # REVIEWER SUGGESTION
  # Record observed total ANPP values for the validation subset, and predict ANPP values from litter and wood production models
    TotalValuesPredicted_sep[,i] <- LitterValuesPredicted_i + WoodValuesPredicted_i

  # Fit a pearson correlation between predicted and observed total ANPP using leaf-area profiles, and record p-value.
  # Fit a model of predicted and observed total ANPP using leaf-area profiles, and record intercept, slope, and r-squared values.
    # Deming regression
    TotalDeming <- mcr::mcreg(TotalValuesPredicted_sep[,i],LAItest$ANPP,method.reg="Deming",error.ratio=1,method.ci="analytical")
    TotalRpt_sep[i,1] <- cor.test(x=TotalValuesPredicted_sep[,i], y=LAItest$ANPP, method="pearson")$p.value
    TotalRpt_sep[i,2] <- mcr::getCoefficients(TotalDeming)[1,1]
    TotalRpt_sep[i,3] <- mcr::getCoefficients(TotalDeming)[2,1]
    TotalRpt_sep[i,4] <- cor.test(x=TotalValuesPredicted_sep[,i], y=LAItest$ANPP, method="pearson")$estimate^2
    }

# Create data frames to store summary results from repeated sampling for leaf-area profile models.    
  TotalQuantiles_sep <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  
# Loop through each column (p-value, intercenpt, slope, and r-squared), compute summary statistics.
  for(i in 1:4){
    TotalQuantiles_sep[i,c("lower","median","upper")] <- quantile(x=TotalRpt_sep[,i], probs=c(0.025,0.5,0.975))
    TotalQuantiles_sep[i,c("mean")] <- mean(TotalRpt_sep[,i])
  }

```

```{r PLSR with alternate sampling method, include=FALSE}

# Re-run PLS models to verify that using an alternate random sampling method (ensuring equal representation of each edaphic class) does not influence results.
  LitterRpt.alt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)
  WoodRpt.alt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)
  TotalRpt.alt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)
  
  LitterLAIRpt.alt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)
  WoodLAIRpt.alt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)
  TotalLAIRpt.alt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)
  
  LitterRHRpt.alt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)
  WoodRHRpt.alt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)
  TotalRHRpt.alt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)
  
  # Create data frames to store observed values of litter production, wood production, and total ANPP for validation plots
  LitterValuesObserved.alt <- matrix(nrow=testsize, ncol=niter, data=NA)
  WoodValuesObserved.alt <- matrix(nrow=testsize, ncol=niter, data=NA)
  TotalValuesObserved.alt <- matrix(nrow=testsize, ncol=niter, data=NA)
  
  LitterValuesPredicted.alt <- matrix(nrow=testsize, ncol=niter, data=NA)
  WoodValuesPredicted.alt <- matrix(nrow=testsize, ncol=niter, data=NA)
  TotalValuesPredicted.alt <- matrix(nrow=testsize, ncol=niter, data=NA)
  
  LitterValuesPredicted.altLAI <- matrix(nrow=testsize, ncol=niter, data=NA)
  WoodValuesPredicted.altLAI <- matrix(nrow=testsize, ncol=niter, data=NA)
  TotalValuesPredicted.altLAI <- matrix(nrow=testsize, ncol=niter, data=NA)
  
  LitterValuesPredicted.altRH <- matrix(nrow=testsize, ncol=niter, data=NA)
  WoodValuesPredicted.altRH <- matrix(nrow=testsize, ncol=niter, data=NA)
  TotalValuesPredicted.altRH <- matrix(nrow=testsize, ncol=niter, data=NA)
  
  TestPlotIDs.alt <- matrix(nrow=testsize, ncol=niter, data=NA)
  
  SampleList.alt <- matrix(nrow=niter,ncol=(18-testsize),data=NA)

  set.seed(1)
  
# For each random sample, sample 3 of 6 plots for each edaphic class. Plots 1-6, 7-12, and 13-18 are different edaphic classes.
  for(i in 1:niter){
    SampleList.alt[i,] <- c(sample(1:6,size=(18-testsize)/3, replace=F),sample(7:12,size=(18-testsize)/3, replace=F),sample(13:18,size=(18-testsize)/3, replace=F))
  }

# Otherwise, code is unchanged from above:  
  for(i in 1:niter){
    LAItrain <- CARBONO[SampleList.alt[i,],]
    LAItest <- CARBONO[-SampleList.alt[i,],]
    TestPlotIDs.alt[,i] <- substr(LAItest$plot, start=1, stop=1)
    
    Litter.PLS <- pls::plsr(Litter~LAI, ncomp=3, data=LAItrain, validation="LOO")
    Wood.PLS <- pls::plsr(Wood~LAI, ncomp=3, data=LAItrain, validation="LOO")
    Total.PLS <- pls::plsr(ANPP~LAI, ncomp=3, data=LAItrain, validation="LOO")
    
    LitterRH.PLS <- pls::plsr(Litter~RH, ncomp=3, data=LAItrain, validation="LOO")
    WoodRH.PLS <- pls::plsr(Wood~RH, ncomp=3, data=LAItrain, validation="LOO")
    TotalRH.PLS <- pls::plsr(ANPP~RH, ncomp=3, data=LAItrain, validation="LOO")
    
    Litter.LAI <- lm(Litter~TotalLAI, data=LAItrain)
    Wood.LAI <- lm(Wood~TotalLAI, data=LAItrain)
    Total.LAI <- lm(ANPP~TotalLAI, data=LAItrain)
    
    # Store correlation p-value for model with three components
      LitterValuesObserved.alt[,i] <- LAItest$Litter
      LitterValuesPredicted.alt[,i] <- predict(Litter.PLS, ncomp=3, newdata=LAItest)
      LitterValuesPredicted.altLAI[,i] <- predict(Litter.LAI, newdata=LAItest)
      LitterValuesPredicted.altRH[,i] <- predict(LitterRH.PLS, ncomp=3, newdata=LAItest)
      
      WoodValuesObserved.alt[,i] <- LAItest$Wood
      WoodValuesPredicted.alt[,i] <- predict(Wood.PLS, ncomp=3, newdata=LAItest)
      WoodValuesPredicted.altLAI[,i] <- predict(Wood.LAI, newdata=LAItest)
      WoodValuesPredicted.altRH[,i] <- predict(WoodRH.PLS, ncomp=3, newdata=LAItest)
    
      TotalValuesObserved.alt[,i] <- LAItest$ANPP
      TotalValuesPredicted.alt[,i] <- predict(Total.PLS, ncomp=3, newdata=LAItest)
      TotalValuesPredicted.altLAI[,i] <- predict(Total.LAI, newdata=LAItest)
      TotalValuesPredicted.altRH[,i] <- predict(TotalRH.PLS, ncomp=3, newdata=LAItest)    
      
        # Fit a pearson correlation between predicted and observed litter production using leaf-area profiles, and record p-value.
  # Fit a model of predicted and observed litter production using leaf-area profiles, and record intercept, slope, and r-squared values.
    # Deming regression
    LitterDeming <- mcr::mcreg(LitterValuesPredicted.alt[,i],LAItest$Litter,method.reg="Deming",error.ratio=1,method.ci="analytical")
    LitterRpt.alt[i,1] <- cor.test(x=LitterValuesPredicted.alt[,i], y=LAItest$Litter, method="pearson")$p.value
    LitterRpt.alt[i,2] <- mcr::getCoefficients(LitterDeming)[1,1]
    LitterRpt.alt[i,3] <- mcr::getCoefficients(LitterDeming)[2,1]
    LitterRpt.alt[i,4] <- cor.test(x=LitterValuesPredicted.alt[,i], y=LAItest$Litter, method="pearson")$estimate^2
  
  # Fit a pearson correlation between predicted and observed wood production using leaf-area profiles, and record p-value.
  # Fit a model of predicted and observed wood production using leaf-area profiles, and record intercept, slope, and r-squared values.   
    # Deming regression
    WoodDeming <- mcr::mcreg(WoodValuesPredicted.alt[,i],LAItest$Wood,method.reg="Deming",error.ratio=1,method.ci="analytical")
    WoodRpt.alt[i,1] <- cor.test(x=WoodValuesPredicted.alt[,i], y=LAItest$Wood, method="pearson")$p.value
    WoodRpt.alt[i,2] <- mcr::getCoefficients(WoodDeming)[1,1]
    WoodRpt.alt[i,3] <- mcr::getCoefficients(WoodDeming)[2,1]
    WoodRpt.alt[i,4] <- cor.test(x=WoodValuesPredicted.alt[,i], y=LAItest$Wood, method="pearson")$estimate^2
  
  # Fit a pearson correlation between predicted and observed total ANPP using leaf-area profiles, and record p-value.
  # Fit a model of predicted and observed total ANPP using leaf-area profiles, and record intercept, slope, and r-squared values.   
    # Deming regression instead
    TotalDeming <- mcr::mcreg(TotalValuesPredicted.alt[,i],LAItest$ANPP,method.reg="Deming",error.ratio=1,method.ci="analytical")
    TotalRpt.alt[i,1] <- cor.test(x=TotalValuesPredicted.alt[,i], y=LAItest$ANPP, method="pearson")$p.value
    TotalRpt.alt[i,2] <- mcr::getCoefficients(TotalDeming)[1,1]
    TotalRpt.alt[i,3] <- mcr::getCoefficients(TotalDeming)[2,1]
    TotalRpt.alt[i,4] <- cor.test(x=TotalValuesPredicted.alt[,i], y=LAItest$ANPP, method="pearson")$estimate^2
 
  # Fit a pearson correlation between predicted and observed litter production using total leaf area, and record p-value.
  # Fit a model of predicted and observed litter production using total leaf area, and record intercept, slope, and r-squared values.   
    # Deming regression instead
    LitterDeming <- mcr::mcreg(LitterValuesPredicted.altLAI[,i],LAItest$Litter,method.reg="Deming",error.ratio=1,method.ci="analytical")
    LitterLAIRpt.alt[i,1] <- cor.test(x=LitterValuesPredicted.altLAI[,i], y=LAItest$Litter, method="pearson")$p.value
    LitterLAIRpt.alt[i,2] <- mcr::getCoefficients(LitterDeming)[1,1]
    LitterLAIRpt.alt[i,3] <- mcr::getCoefficients(LitterDeming)[2,1]
    LitterLAIRpt.alt[i,4] <- cor.test(x=LitterValuesPredicted.altLAI[,i], y=LAItest$Litter, method="pearson")$estimate^2
    
  # Fit a pearson correlation between predicted and observed wood production using total leaf area, and record p-value.
  # Fit a model of predicted and observed wood production using total leaf area, and record intercept, slope, and r-squared values.      
    # Deming regression instead
    WoodDeming <- mcr::mcreg(WoodValuesPredicted.altLAI[,i],LAItest$Wood,method.reg="Deming",error.ratio=1,method.ci="analytical")
    WoodLAIRpt.alt[i,1] <- cor.test(x=WoodValuesPredicted.altLAI[,i], y=LAItest$Wood, method="pearson")$p.value
    WoodLAIRpt.alt[i,2] <- mcr::getCoefficients(WoodDeming)[1,1]
    WoodLAIRpt.alt[i,3] <- mcr::getCoefficients(WoodDeming)[2,1]
    WoodLAIRpt.alt[i,4] <- cor.test(x=WoodValuesPredicted.altLAI[,i], y=LAItest$Wood, method="pearson")$estimate^2
    
  # Fit a pearson correlation between predicted and observed total ANPP using total leaf area, and record p-value.
  # Fit a model of predicted and observed total ANPP using total leaf area, and record intercept, slope, and r-squared values.      
    # Deming regression
    TotalDeming <- mcr::mcreg(TotalValuesPredicted.altLAI[,i],LAItest$ANPP,method.reg="Deming",error.ratio=1,method.ci="analytical")
    TotalLAIRpt.alt[i,1] <- cor.test(x=TotalValuesPredicted.altLAI[,i], y=LAItest$ANPP, method="pearson")$p.value
    TotalLAIRpt.alt[i,2] <- mcr::getCoefficients(TotalDeming)[1,1]
    TotalLAIRpt.alt[i,3] <- mcr::getCoefficients(TotalDeming)[2,1]
    TotalLAIRpt.alt[i,4] <- cor.test(x=TotalValuesPredicted.altLAI[,i], y=LAItest$ANPP, method="pearson")$estimate^2
    
    
  # Fit a pearson correlation between predicted and observed litter production using lidar DRH profiles, and record p-value.
  # Fit a model of predicted and observed litter production using lidar DRH profiles, and record intercept, slope, and r-squared values. 
    # Deming regression instead
    LitterDeming <- mcr::mcreg(LitterValuesPredicted.altRH[,i],LAItest$Litter,method.reg="Deming",error.ratio=1,method.ci="analytical")
    LitterRHRpt.alt[i,1] <- cor.test(x=LitterValuesPredicted.altRH[,i], y=LAItest$Litter, method="pearson")$p.value
    LitterRHRpt.alt[i,2] <- mcr::getCoefficients(LitterDeming)[1,1]
    LitterRHRpt.alt[i,3] <- mcr::getCoefficients(LitterDeming)[2,1]
    LitterRHRpt.alt[i,4] <- cor.test(x=LitterValuesPredicted.altRH[,i], y=LAItest$Litter, method="pearson")$estimate^2
 
  # Fit a pearson correlation between predicted and observed wood production using lidar DRH profiles, and record p-value.
  # Fit a model of predicted and observed wood production using lidar DRH profiles, and record intercept, slope, and r-squared values.   
    # Deming regression instead
    WoodDeming <- mcr::mcreg(WoodValuesPredicted.altRH[,i],LAItest$Wood,method.reg="Deming",error.ratio=1,method.ci="analytical")
    WoodRHRpt.alt[i,1] <- cor.test(x=WoodValuesPredicted.altRH[,i], y=LAItest$Wood, method="pearson")$p.value
    WoodRHRpt.alt[i,2] <- mcr::getCoefficients(WoodDeming)[1,1]
    WoodRHRpt.alt[i,3] <- mcr::getCoefficients(WoodDeming)[2,1]
    WoodRHRpt.alt[i,4] <- cor.test(x=WoodValuesPredicted.altRH[,i], y=LAItest$Wood, method="pearson")$estimate^2
    
  # Fit a pearson correlation between predicted and observed total ANPP using lidar DRH profiles, and record p-value.
  # Fit a model of predicted and observed total ANPP using lidar DRH profiles, and record intercept, slope, and r-squared values.        
    # Deming regression
    TotalDeming <- mcr::mcreg(TotalValuesPredicted.altRH[,i],LAItest$ANPP,method.reg="Deming",error.ratio=1,method.ci="analytical")
    TotalRHRpt.alt[i,1] <- cor.test(x=TotalValuesPredicted.altRH[,i], y=LAItest$ANPP, method="pearson")$p.value
    TotalRHRpt.alt[i,2] <- mcr::getCoefficients(TotalDeming)[1,1]
    TotalRHRpt.alt[i,3] <- mcr::getCoefficients(TotalDeming)[2,1]
    TotalRHRpt.alt[i,4] <- cor.test(x=TotalValuesPredicted.altRH[,i], y=LAItest$ANPP, method="pearson")$estimate^2

  }
  
  LitterQuantiles.alt <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  WoodQuantiles.alt <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  TotalQuantiles.alt <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  
  WoodLAIQuantiles.alt <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  LitterLAIQuantiles.alt <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  TotalLAIQuantiles.alt <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  
  WoodRHQuantiles.alt <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  LitterRHQuantiles.alt <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  TotalRHQuantiles.alt <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  
  
  for(i in 1:4){
    LitterQuantiles.alt[i,c("lower","median","upper")] <- quantile(x=LitterRpt.alt[,i], probs=c(0.025,0.5,0.975))
    LitterQuantiles.alt[i,c("mean")] <- mean(LitterRpt.alt[,i])
    WoodQuantiles.alt[i,c("lower","median","upper")] <- quantile(x=WoodRpt.alt[,i], probs=c(0.025,0.5,0.975))
    WoodQuantiles.alt[i,c("mean")] <- mean(WoodRpt.alt[,i])
    TotalQuantiles.alt[i,c("lower","median","upper")] <- quantile(x=TotalRpt.alt[,i], probs=c(0.025,0.5,0.975))
    TotalQuantiles.alt[i,c("mean")] <- mean(TotalRpt.alt[,i])
    
    LitterLAIQuantiles.alt[i,c("lower","median","upper")] <- quantile(x=LitterLAIRpt.alt[,i], probs=c(0.025,0.5,0.975))
    LitterLAIQuantiles.alt[i,c("mean")] <- mean(LitterLAIRpt.alt[,i])
    WoodLAIQuantiles.alt[i,c("lower","median","upper")] <- quantile(x=WoodLAIRpt.alt[,i], probs=c(0.025,0.5,0.975))
    WoodLAIQuantiles.alt[i,c("mean")] <- mean(WoodLAIRpt.alt[,i])
    TotalLAIQuantiles.alt[i,c("lower","median","upper")] <- quantile(x=TotalLAIRpt.alt[,i], probs=c(0.025,0.5,0.975))
    TotalLAIQuantiles.alt[i,c("mean")] <- mean(TotalLAIRpt.alt[,i])
    
    LitterRHQuantiles.alt[i,c("lower","median","upper")] <- quantile(x=LitterRHRpt.alt[,i], probs=c(0.025,0.5,0.975))
    LitterRHQuantiles.alt[i,c("mean")] <- mean(LitterRHRpt.alt[,i])
    WoodRHQuantiles.alt[i,c("lower","median","upper")] <- quantile(x=WoodRHRpt.alt[,i], probs=c(0.025,0.5,0.975))
    WoodRHQuantiles.alt[i,c("mean")] <- mean(WoodRHRpt.alt[,i])
    TotalRHQuantiles.alt[i,c("lower","median","upper")] <- quantile(x=TotalRHRpt.alt[,i], probs=c(0.025,0.5,0.975))
    TotalRHQuantiles.alt[i,c("mean")] <- mean(TotalRHRpt.alt[,i])
  }
  
  #   Calculate loadings
  TotalC1Loadings.alt <- matrix(nrow = 60, ncol=niter, data=NA)
  TotalC2Loadings.alt <- matrix(nrow = 60, ncol=niter, data=NA)
  TotalC3Loadings.alt <- matrix(nrow = 60, ncol=niter, data=NA)
  TotalWeights.alt <- matrix(nrow = 60, ncol=niter, data=NA)
  
  for(i in 1:niter){
    LAItrain <- CARBONO[SampleList.alt[i,],]
    LAItest <- CARBONO[-SampleList.alt[i,],]
    Total.PLS <- pls::plsr(ANPP~LAI, ncomp=3, data=LAItrain, validation="LOO")
    TotalC1Loadings.alt[,i] <- Total.PLS$loadings[,1]
    TotalC2Loadings.alt[,i] <- Total.PLS$loadings[,2]
    TotalC3Loadings.alt[,i] <- Total.PLS$loadings[,3]
    
    Comp1Var <- 100*drop(pls::R2(Total.PLS, estimate = "train",intercept = FALSE)$val)[1]
    Comp2Var <- 100*drop(pls::R2(Total.PLS, estimate = "train",intercept = FALSE)$val)[2]-Comp1Var
    Comp3Var <- 100*drop(pls::R2(Total.PLS, estimate = "train",intercept = FALSE)$val)[3]-Comp1Var-Comp2Var
    
    TotalWeights.alt[,i] <- Total.PLS$loadings[,1]*Comp1Var + Total.PLS$loadings[,2]*Comp2Var + Total.PLS$loadings[,3]*Comp3Var
  }
  
  TotalC1LoadingsSummary.alt <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
  TotalC2LoadingsSummary.alt <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
  TotalC3LoadingsSummary.alt <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
  TotalWeightsSummary.alt <- data.frame(height=60:1, min=NA, median=NA, max=NA, mean=NA)
  
  for(i in 1:60){
    TotalC1LoadingsSummary.alt[i,c('min','median','max')] <- quantile(TotalC1Loadings.alt[i,], probs=c(0.025,0.5,0.975))
      TotalC1LoadingsSummary.alt[i,'mean'] <- mean(TotalC1Loadings.alt[i,])
    TotalC2LoadingsSummary.alt[i,c('min','median','max')] <- quantile(TotalC2Loadings.alt[i,], probs=c(0.025,0.5,0.975))
      TotalC2LoadingsSummary.alt[i,'mean'] <- mean(TotalC2Loadings.alt[i,])
    TotalC3LoadingsSummary.alt[i,c('min','median','max')] <- quantile(TotalC3Loadings.alt[i,], probs=c(0.025,0.5,0.975))
      TotalC3LoadingsSummary.alt[i,'mean'] <- mean(TotalC3Loadings.alt[i,])
    TotalWeightsSummary.alt[i,c('min','median','max')] <- quantile(TotalWeights.alt[i,], probs=c(0.025,0.5,0.975))
      TotalWeightsSummary.alt[i,'mean'] <- mean(TotalWeights.alt[i,])
  }
```

```{r PLSR with one component, include=FALSE}

# Create data frames to store result from leaf-area profile PLS models to predict litter production, wood production, and total ANPP
  LitterRpt_simple <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)
  WoodRpt_simple <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)
  TotalRpt_simple <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA, fitx=NA, fity=NA)

# Create data frames to store result from lidar discrete RH models to predict litter production, wood production, and total ANPP
  LitterRHRpt_simple <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)
  WoodRHRpt_simple <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)
  TotalRHRpt_simple <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)

# Create data frames to store predicted (leaf-area profile PLS) values of litter production, wood production, and total ANPP for validation plots  
  LitterValuesPredicted_simple <- matrix(nrow=testsize, ncol=niter, data=NA)
  WoodValuesPredicted_simple <- matrix(nrow=testsize, ncol=niter, data=NA)
  TotalValuesPredicted_simple <- matrix(nrow=testsize, ncol=niter, data=NA)

# Create data frames to store predicted (lidar discrete RH) values of litter production, wood production, and total ANPP for validation plots  
  LitterValuesPredictedRH_simple <- matrix(nrow=testsize, ncol=niter, data=NA)
  WoodValuesPredictedRH_simple <- matrix(nrow=testsize, ncol=niter, data=NA)
  TotalValuesPredictedRH_simple <- matrix(nrow=testsize, ncol=niter, data=NA)

# For each sample, predict litter production, wood production, and total ANPP using three methods.  
for(i in 1:niter){
  # Split data into subsets for model training (LAI train) and model testing (LAI test)
    LAItrain <- CARBONO[SampleList[i,],]
    LAItest <- CARBONO[-SampleList[i,],]
  # Record the IDs of plots used for model testing
    TestPlotIDs[,i] <- substr(LAItest$plot, start=1, stop=1)
  
  # Fit PLS models to predict litter production, wood production, and total ANPP from leaf-area profiles
    Litter.PLS <- pls::plsr(Litter~LAI, ncomp=1, data=LAItrain, validation="LOO")
      LitterRpt_simple[i,"fitx"] <- sum(pls::explvar(Litter.PLS))
      LitterRpt_simple[i,"fity"] <- 100*drop(pls::R2(Litter.PLS, estimate = "train",intercept = FALSE)$val)[3]
    Wood.PLS <- pls::plsr(Wood~LAI, ncomp=1, data=LAItrain, validation="LOO")
      WoodRpt_simple[i,"fitx"] <- sum(pls::explvar(Wood.PLS))
      WoodRpt_simple[i,"fity"] <- 100*drop(pls::R2(Wood.PLS, estimate = "train",intercept = FALSE)$val)[3]
    Total.PLS <- pls::plsr(ANPP~LAI, ncomp=1, data=LAItrain, validation="LOO")
      TotalRpt_simple[i,"fitx"] <- sum(pls::explvar(Total.PLS))
      TotalRpt_simple[i,"fity"] <- 100*drop(pls::R2(Total.PLS, estimate = "train",intercept = FALSE)$val)[3]
      
  # Fit PLS models to predict litter production, wood production, and total ANPP from lidar DRH profiles  
    LitterRH.PLS <- pls::plsr(Litter~RH, ncomp=1, data=LAItrain, validation="LOO")
    WoodRH.PLS <- pls::plsr(Wood~RH, ncomp=1, data=LAItrain, validation="LOO")
    TotalRH.PLS <- pls::plsr(ANPP~RH, ncomp=1, data=LAItrain, validation="LOO")

  # Record observed litter production values for the validation subset, and predict litter production values for each model
    LitterValuesPredicted_simple[,i] <- predict(Litter.PLS, ncomp=1, newdata=LAItest)
    LitterValuesPredictedRH_simple[,i] <- predict(LitterRH.PLS, ncomp=1, newdata=LAItest)

  # Record observed wood production values for the validation subset, and predict litter production values for each model
    WoodValuesPredicted_simple[,i] <- predict(Wood.PLS, ncomp=1, newdata=LAItest)
    WoodValuesPredictedRH_simple[,i] <- predict(WoodRH.PLS, ncomp=1, newdata=LAItest)

  # Record observed total ANPP values for the validation subset, and predict litter production values for each model
    TotalValuesPredicted_simple[,i] <- predict(Total.PLS, ncomp=1, newdata=LAItest)
    TotalValuesPredictedRH_simple[,i] <- predict(TotalRH.PLS, ncomp=1, newdata=LAItest)

  # Fit a pearson correlation between predicted and observed litter production using leaf-area profiles, and record p-value.
  # Fit a model of predicted and observed litter production using leaf-area profiles, and record intercept, slope, and r-squared values.
    # Deming regression
    LitterDeming <- mcr::mcreg(LitterValuesPredicted_simple[,i],LAItest$Litter,method.reg="Deming",error.ratio=1,method.ci="analytical")
    LitterRpt_simple[i,1] <- cor.test(x=LitterValuesPredicted_simple[,i], y=LAItest$Litter, method="pearson")$p.value
    LitterRpt_simple[i,2] <- mcr::getCoefficients(LitterDeming)[1,1]
    LitterRpt_simple[i,3] <- mcr::getCoefficients(LitterDeming)[2,1]
    LitterRpt_simple[i,4] <- cor.test(x=LitterValuesPredicted_simple[,i], y=LAItest$Litter, method="pearson")$estimate^2
  
  # Fit a pearson correlation between predicted and observed wood production using leaf-area profiles, and record p-value.
  # Fit a model of predicted and observed wood production using leaf-area profiles, and record intercept, slope, and r-squared values.   
    # Deming regression
    WoodDeming <- mcr::mcreg(WoodValuesPredicted_simple[,i],LAItest$Wood,method.reg="Deming",error.ratio=1,method.ci="analytical")
    WoodRpt_simple[i,1] <- cor.test(x=WoodValuesPredicted_simple[,i], y=LAItest$Wood, method="pearson")$p.value
    WoodRpt_simple[i,2] <- mcr::getCoefficients(WoodDeming)[1,1]
    WoodRpt_simple[i,3] <- mcr::getCoefficients(WoodDeming)[2,1]
    WoodRpt_simple[i,4] <- cor.test(x=WoodValuesPredicted_simple[,i], y=LAItest$Wood, method="pearson")$estimate^2
  
  # Fit a pearson correlation between predicted and observed total ANPP using leaf-area profiles, and record p-value.
  # Fit a model of predicted and observed total ANPP using leaf-area profiles, and record intercept, slope, and r-squared values.   
    # Deming regression instead
    TotalDeming <- mcr::mcreg(TotalValuesPredicted_simple[,i],LAItest$ANPP,method.reg="Deming",error.ratio=1,method.ci="analytical")
    TotalRpt_simple[i,1] <- cor.test(x=TotalValuesPredicted_simple[,i], y=LAItest$ANPP, method="pearson")$p.value
    TotalRpt_simple[i,2] <- mcr::getCoefficients(TotalDeming)[1,1]
    TotalRpt_simple[i,3] <- mcr::getCoefficients(TotalDeming)[2,1]
    TotalRpt_simple[i,4] <- cor.test(x=TotalValuesPredicted_simple[,i], y=LAItest$ANPP, method="pearson")$estimate^2
 
  # Fit a pearson correlation between predicted and observed litter production using lidar DRH profiles, and record p-value.
  # Fit a model of predicted and observed litter production using lidar DRH profiles, and record intercept, slope, and r-squared values. 
    # Deming regression instead
    LitterDeming <- mcr::mcreg(LitterValuesPredictedRH_simple[,i],LAItest$Litter,method.reg="Deming",error.ratio=1,method.ci="analytical")
    LitterRHRpt_simple[i,1] <- cor.test(x=LitterValuesPredictedRH_simple[,i], y=LAItest$Litter, method="pearson")$p.value
    LitterRHRpt_simple[i,2] <- mcr::getCoefficients(LitterDeming)[1,1]
    LitterRHRpt_simple[i,3] <- mcr::getCoefficients(LitterDeming)[2,1]
    LitterRHRpt_simple[i,4] <- cor.test(x=LitterValuesPredictedRH_simple[,i], y=LAItest$Litter, method="pearson")$estimate^2
 
  # Fit a pearson correlation between predicted and observed wood production using lidar DRH profiles, and record p-value.
  # Fit a model of predicted and observed wood production using lidar DRH profiles, and record intercept, slope, and r-squared values.   
    # Deming regression instead
    WoodDeming <- mcr::mcreg(WoodValuesPredictedRH_simple[,i],LAItest$Wood,method.reg="Deming",error.ratio=1,method.ci="analytical")
    WoodRHRpt_simple[i,1] <- cor.test(x=WoodValuesPredictedRH_simple[,i], y=LAItest$Wood, method="pearson")$p.value
    WoodRHRpt_simple[i,2] <- mcr::getCoefficients(WoodDeming)[1,1]
    WoodRHRpt_simple[i,3] <- mcr::getCoefficients(WoodDeming)[2,1]
    WoodRHRpt_simple[i,4] <- cor.test(x=WoodValuesPredictedRH_simple[,i], y=LAItest$Wood, method="pearson")$estimate^2
    
  # Fit a pearson correlation between predicted and observed total ANPP using lidar DRH profiles, and record p-value.
  # Fit a model of predicted and observed total ANPP using lidar DRH profiles, and record intercept, slope, and r-squared values.        
    # Deming regression
    TotalDeming <- mcr::mcreg(TotalValuesPredictedRH_simple[,i],LAItest$ANPP,method.reg="Deming",error.ratio=1,method.ci="analytical")
    TotalRHRpt_simple[i,1] <- cor.test(x=TotalValuesPredictedRH_simple[,i], y=LAItest$ANPP, method="pearson")$p.value
    TotalRHRpt_simple[i,2] <- mcr::getCoefficients(TotalDeming)[1,1]
    TotalRHRpt_simple[i,3] <- mcr::getCoefficients(TotalDeming)[2,1]
    TotalRHRpt_simple[i,4] <- cor.test(x=TotalValuesPredictedRH_simple[,i], y=LAItest$ANPP, method="pearson")$estimate^2
    }

# Create data frames to store summary results from repeated sampling for leaf-area profile models.    
  LitterQuantiles_simple <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  WoodQuantiles_simple <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  TotalQuantiles_simple <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)

# Create data frames to store summary results from repeated sampling for lidar DRH profile models.
  WoodRHQuantiles_simple <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  LitterRHQuantiles_simple <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  TotalRHQuantiles_simple <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)

# Loop through each column (p-value, intercenpt, slope, and r-squared), compute summary statistics.
  for(i in 1:4){
    LitterQuantiles_simple[i,c("lower","median","upper")] <- quantile(x=LitterRpt_simple[,i], probs=c(0.025,0.5,0.975))
    LitterQuantiles_simple[i,c("mean")] <- mean(LitterRpt_simple[,i])
    WoodQuantiles_simple[i,c("lower","median","upper")] <- quantile(x=WoodRpt_simple[,i], probs=c(0.025,0.5,0.975))
    WoodQuantiles_simple[i,c("mean")] <- mean(WoodRpt_simple[,i])
    TotalQuantiles_simple[i,c("lower","median","upper")] <- quantile(x=TotalRpt_simple[,i], probs=c(0.025,0.5,0.975))
    TotalQuantiles_simple[i,c("mean")] <- mean(TotalRpt_simple[,i])

    LitterRHQuantiles_simple[i,c("lower","median","upper")] <- quantile(x=LitterRHRpt_simple[,i], probs=c(0.025,0.5,0.975))
    LitterRHQuantiles_simple[i,c("mean")] <- mean(LitterRHRpt_simple[,i])
    WoodRHQuantiles_simple[i,c("lower","median","upper")] <- quantile(x=WoodRHRpt_simple[,i], probs=c(0.025,0.5,0.975))
    WoodRHQuantiles_simple[i,c("mean")] <- mean(WoodRHRpt_simple[,i])
    TotalRHQuantiles_simple[i,c("lower","median","upper")] <- quantile(x=TotalRHRpt_simple[,i], probs=c(0.025,0.5,0.975))
    TotalRHQuantiles_simple[i,c("mean")] <- mean(TotalRHRpt_simple[,i])
  }

```

```{r Canopy gap-phase dynamics, include=FALSE}

    CanopyHt <- read.csv("Z:/LaSelvaManuscript/Archive/annualcanopyheightdynamics1999_2015fulldataset.csv")
      CanopyYrs <- 2000:2009
    CanopySum <- data.frame(plot=rep(plots,each=length(CanopyYrs)),
                             Year=rep(CanopyYrs,length(plots)),
                             PropGap=NA)

    for(i in 1:length(plots)){
      for(j in 1:length(CanopyYrs)){
        CanopySum[CanopySum$plot==plots[i] & CanopySum$Year==CanopyYrs[j],'PropGap'] <- dim(CanopyHt[CanopyHt$plot==plots[i] & CanopyHt$Year==CanopyYrs[j] & CanopyHt$height_cm<1500,])[1]/231
      }
    }
    
  CARBONO$CanopySlope <- NA
  CARBONO$CanopyMean <- NA
  for(i in 1:length(plots)){
    CanopyLM <- lm(PropGap~Year,data=CanopySum[CanopySum$plot==plots[i],])
    CARBONO[CARBONO$plot==plots[i],"CanopySlope"] <- summary(CanopyLM)$coefficients[2,1]
    CARBONO[CARBONO$plot==plots[i],"CanopyMean"] <- mean(CanopySum[CanopySum$plot==plots[i],'PropGap'])
  }

# Create data frames to store result from leaf-area profile PLS models to predict litter production, wood production, and total ANPP
  DensityRpt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)
  GapRpt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)
  GapFromProfilesRpt <- data.frame(pval=NA, intercept=NA, slope=NA, r=NA)
  
# Create data frames to store observed and predicted values of ANPP 
  TotalValuesObserved <- matrix(nrow=testsize, ncol=niter, data=NA)
  DensityValuesPredicted <- matrix(nrow=testsize, ncol=niter, data=NA)
  GapValuesPredicted <- matrix(nrow=testsize, ncol=niter, data=NA)

# For each sample, predict litter production, wood production, and total ANPP using three methods.  
for(i in 1:niter){
  # Split data into subsets for model training (LAI train) and model testing (LAI test)
    LAItrain <- CARBONO[SampleList[i,],]
    LAItest <- CARBONO[-SampleList[i,],]

    DensityModel <- lm(ANPP~WSG, data=LAItrain)
    GapModel <- lm(ANPP~CanopySlope, data=LAItrain)
    
    # Does change in low-canopy area correlate with leaf-area profiles?
    GapPLS <- pls::plsr(CanopySlope~LAI, ncomp=3, data=LAItrain, validation="LOO")

  # Record observed total ANPP values for the validation subset, and predict ANPP values for each model
  TotalValuesObserved[,i] <- LAItest$ANPP
  DensityValuesPredicted[,i] <- predict(DensityModel, newdata=LAItest)
  GapValuesPredicted[,i] <- predict(GapModel, newdata=LAItest)
  
  GapChangePredicted <- predict(GapPLS, newdata=LAItest, ncomp=3)
  
  # Fit a pearson correlation between predicted and observed total ANPP, and record p-value.
  # Fit a model of predicted and observed total ANPP , and record intercept, slope, and r-squared values. 
    # Deming regression
    DensityDeming <- mcr::mcreg(DensityValuesPredicted[,i],LAItest$ANPP,method.reg="Deming",error.ratio=1,method.ci="analytical")
    DensityRpt[i,1] <- cor.test(x=DensityValuesPredicted[,i], y=LAItest$ANPP, method="pearson")$p.value
    DensityRpt[i,2] <- mcr::getCoefficients(DensityDeming)[1,1]
    DensityRpt[i,3] <- mcr::getCoefficients(DensityDeming)[2,1]
    DensityRpt[i,4] <- cor.test(x=DensityValuesPredicted[,i], y=LAItest$ANPP, method="pearson")$estimate^2

    GapDeming <- mcr::mcreg(GapValuesPredicted[,i],LAItest$ANPP,method.reg="Deming",error.ratio=1,method.ci="analytical")
    GapRpt[i,1] <- cor.test(x=GapValuesPredicted[,i], y=LAItest$ANPP, method="pearson")$p.value
    GapRpt[i,2] <- mcr::getCoefficients(GapDeming)[1,1]
    GapRpt[i,3] <- mcr::getCoefficients(GapDeming)[2,1]
    GapRpt[i,4] <- cor.test(x=GapValuesPredicted[,i], y=LAItest$ANPP, method="pearson")$estimate^2
    
    GapDeming2 <- mcr::mcreg(GapChangePredicted,LAItest$ANPP,method.reg="Deming",error.ratio=1,method.ci="analytical")
    GapFromProfilesRpt[i,1] <- cor.test(x=GapChangePredicted, y=LAItest$ANPP, method="pearson")$p.value
    GapFromProfilesRpt[i,2] <- mcr::getCoefficients(GapDeming2)[1,1]
    GapFromProfilesRpt[i,3] <- mcr::getCoefficients(GapDeming2)[2,1]
    GapFromProfilesRpt[i,4] <- cor.test(x=GapChangePredicted, y=LAItest$ANPP, method="pearson")$estimate^2
 }

# Create data frames to store summary results from repeated sampling.    
  DensityQuantiles <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  GapQuantiles <- data.frame(components=c("p","intercept","slope","r"), lower=NA, median=NA, upper=NA, mean=NA)
  

# Loop through each column (p-value, intercenpt, slope, and r-squared), compute summary statistics.
  for(i in 1:4){
    DensityQuantiles[i,c("lower","median","upper")] <- quantile(x=DensityRpt[,i], probs=c(0.025,0.5,0.975))
    DensityQuantiles[i,c("mean")] <- mean(DensityRpt[,i])
    
    GapQuantiles[i,c("lower","median","upper")] <- quantile(x=GapRpt[,i], probs=c(0.025,0.5,0.975))
    GapQuantiles[i,c("mean")] <- mean(GapRpt[,i])
  }

```

```{r Method comparison tests, include=FALSE}
# Do Kolmogorov-Smirnov tests to compare distributions of r-squared values of predicted vs observed values in validataion data for different methods.

  # 1. Compare leaf-area profiles vs. total leaf area R^2 values:
    ANPP.ks <- ks.test(x=TotalRpt$r, y= TotalLAIRpt$r)
    Litter.ks <- ks.test(x=LitterRpt$r, y= LitterLAIRpt$r)
    Wood.ks <- ks.test(x=WoodRpt$r, y= WoodLAIRpt$r)
  # 2. Compare leaf-area profiles vs. lidar DRH profiles R^2 values:
    ANPP.ks2 <- ks.test(x=TotalRpt$r, y= TotalRHRpt$r)
    Litter.ks2 <- ks.test(x=LitterRpt$r, y= LitterRHRpt$r)
    Wood.ks2 <- ks.test(x=WoodRpt$r, y= WoodRHRpt$r)
  # 3. Compare compare leaf-area profiles vs. total leaf area slope values:
    ANPP.ks.slope <- ks.test(x=TotalRpt$slope, y= TotalLAIRpt$slope)
  # 4. Compare compare leaf-area profiles vs. lidar DRH profiles slope values:
    ANPP.ks.slope2 <- ks.test(x=TotalRpt$slope, y= TotalRHRpt$slope)
  # 5. Compare leaf-area profiles vs.light-metric profiles:
    ANPP.ks.abs <- ks.test(x=TotalRpt$r, y= TotalRpt_abs$r)
    ANPP.ks.tra <- ks.test(x=TotalRpt$r, y= TotalRpt_tra$r)
    Litter.ks.abs <- ks.test(x=LitterRpt$r, y= LitterRpt_abs$r)
    LItter.ks.tra <- ks.test(x=LitterRpt$r, y= LitterRpt_tra$r)
  # 6. Compare one component PLS models:
    ANPP.ks.simple <- ks.test(x=TotalRpt_simple$r, y= TotalLAIRpt$r)
    ANPP.ks2.simple <- ks.test(x=TotalRpt_simple$r, y= TotalRHRpt_simple$r)
  # 7. Compare alternate sampling method (equal representation of edaphic clases)
    ANPP.alt.ks <- ks.test(x=TotalRpt$r, y=TotalRpt.alt$r)
    ANPP.LAI.alt.ks <- ks.test(x=TotalLAIRpt$r, y=TotalLAIRpt.alt$r)
    ANPP.RH.alt.ks <- ks.test(x=TotalRHRpt$r, y=TotalRHRpt.alt$r)  
    
```

Vertical leaf-area profile models predicted over a third of the variation in ANPP among plots in this forest (Table 1, Fig. 2). The median r2 between observed ANPP and predicted ANPP using vertical leaf-area profile models was `r round(TotalQuantiles[TotalQuantiles$components=="r","median"],2)` (median values and 95% CIs are given in Table 1). The PLS model for litter production performed comparably, with a median r2 of `r round(LitterQuantiles[LitterQuantiles$components=="r","median"],2)`. The wood-production model had a lower median r2 of `r round(WoodQuantiles[WoodQuantiles$components=="r","median"],2)`.

Models using vertical leaf-area profiles predicted significantly more variation in ANPP than models using total leaf area in the absence of vertical information (Fig. 2; D = `r round(ANPP.ks$statistic,3)`, P=`r round(ANPP.ks$p.value,3)`) or models from DRH percentiles (D = `r round(ANPP.ks2$statistic,3)`, P=`r round(ANPP.ks2$p.value,3)`). Linear models predicting productivity from total leaf area had a median r2 of `r round(TotalLAIQuantiles[TotalLAIQuantiles$components=="r","median"],2)` for ANPP using the same 1,000 random samples, a median r2 of `r round(LitterLAIQuantiles[LitterLAIQuantiles$components=="r","median"],2)` for litter production, and a median r2 of `r round(WoodLAIQuantiles[WoodLAIQuantiles$components=="r","median"],2)` for wood production. PLS models predicting productivity from DRH percentiles had a median r2 of `r round(TotalRHQuantiles[TotalRHQuantiles$components=="r","median"],2)` for ANPP, a median r2 of `r round(LitterRHQuantiles[LitterRHQuantiles$components=="r","median"],2)` for litter production, and a median r2 of `r round(WoodRHQuantiles[WoodRHQuantiles$components=="r","median"],2)` for wood production. When predicting ANPP from PLS models with only a single component, vertical leaf-area profiles still significantly outperformed total leaf area models (D = `r round(ANPP.ks.simple$statistic,3)`, P=`r round(ANPP.ks.simple$p.value,3)`) and DRH percentile models also using a single PLS component (Fig. S12; D = `r round(ANPP.ks2.simple$statistic,3)`, P=`r round(ANPP.ks2.simple$p.value,3)`). 

The slope of the relationship between predicted and observed ANPP was significantly closer to one when ANPP was predicted from vertical leaf-area profiles than using models with total leaf area (D = `r round(ANPP.ks.slope$statistic,3)`, P=`r round(ANPP.ks.slope$p.value,3)`) or DRH percentiles (Table 1; Fig. 2; D = `r round(ANPP.ks.slope2$statistic,3)`, P=`r round(ANPP.ks.slope2$p.value,3)`). Using vertical leaf-area profiles, the median slope between predicted and observed ANPP was `r round(TotalQuantiles[TotalQuantiles$components=="slope","median"],2)`. In contrast, the median slope using total leaf area to predict ANPP was `r round(TotalLAIQuantiles[TotalLAIQuantiles$components=="slope","median"],2)`. Using DRH percentiles, the median slope was `r round(TotalRHQuantiles[TotalRHQuantiles$components=="slope","median"],2)`.

Loadings of the PLS components in models that predict ANPP from vertical leaf-area profiles indicate that ANPP increases with leaf area between 10 and 20 m in height and decreases with leaf area between 20 and 30 m in height. The model indicates that leaf area at other heights has a negligible impact on ANPP (Fig. 3).

Using constrained random sampling to ensure equal representation of edaphic classes did not significantly affect the amount of ANPP variation predicted by models using vertical leaf-area profiles (median r2 was `r round(TotalQuantiles[TotalQuantiles$components=="r","median"],2)` in the original analysis and `r round(TotalQuantiles.alt[TotalQuantiles.alt$components=="r","median"],2)` in the alternate analysis; D = `r round(ANPP.alt.ks$statistic,3)`, P = `r round(ANPP.alt.ks$p.value,3)`; Figs. 1, S1), total leaf area (median r2 was `r round(TotalLAIQuantiles[TotalLAIQuantiles$components=="r","median"],2)` in the original analysis and `r round(TotalLAIQuantiles.alt[TotalLAIQuantiles.alt$components=="r","median"],2)` in the alternate analysis; D = `r round(ANPP.LAI.alt.ks$statistic,3)`, P = `r round(ANPP.LAI.alt.ks$p.value,3)`), or DRH percentiles (median r2 was `r round(TotalRHQuantiles[TotalRHQuantiles$components=="r","median"],2)` in the original analysis and `r round(TotalRHQuantiles.alt[TotalRHQuantiles.alt$components=="r","median"],2)` in the alternate analysis; D = `r round(ANPP.RH.alt.ks$statistic,3)`, P = `r round(ANPP.RH.alt.ks$p.value,3)`).

```{r Table 1, include=F, eval=F}
results <- data.frame(Metric=c(rep("Vertical leaf-area profiles",2),
                               rep("Total leaf area",2),
                               rep("DRH percentiles",2)),
                      Metric2=rep(c("median","95% CI"),3),
                      ANPP_R2=NA,
                      ANPP_slope=NA,
                      Litter_R2=NA,
                      Litter_slope=NA,
                      Wood_R2=NA,
                      Wood_slope=NA)

 # Fill in results
  results[results$Metric=="Vertical leaf-area profiles" & results$Metric2=="median","ANPP_R2"] <- round(TotalQuantiles[TotalQuantiles$components=="r","median"],2)
  results[results$Metric=="Vertical leaf-area profiles" & results$Metric2=="median","ANPP_slope"] <- round(TotalQuantiles[TotalQuantiles$components=="slope","median"],2)
  results[results$Metric=="Vertical leaf-area profiles" & results$Metric2=="median","Litter_R2"] <- round(LitterQuantiles[LitterQuantiles$components=="r","median"],2)
  results[results$Metric=="Vertical leaf-area profiles" & results$Metric2=="median","Litter_slope"] <- round(LitterQuantiles[LitterQuantiles$components=="slope","median"],2)
  results[results$Metric=="Vertical leaf-area profiles" & results$Metric2=="median","Wood_R2"] <- round(WoodQuantiles[WoodQuantiles$components=="r","median"],2)
  results[results$Metric=="Vertical leaf-area profiles" & results$Metric2=="median","Wood_slope"] <- round(WoodQuantiles[WoodQuantiles$components=="slope","median"],2)
  
  results[results$Metric=="Vertical leaf-area profiles" & results$Metric2=="95% CI","ANPP_R2"] <- paste("(",round(TotalQuantiles[TotalQuantiles$components=="r","lower"],2),",",round(TotalQuantiles[TotalQuantiles$components=="r","upper"],2),")",sep="")
  results[results$Metric=="Vertical leaf-area profiles" & results$Metric2=="95% CI","ANPP_slope"] <- paste("(",round(TotalQuantiles[TotalQuantiles$components=="slope","lower"],2),",",round(TotalQuantiles[TotalQuantiles$components=="slope","upper"],2),")",sep="")
  results[results$Metric=="Vertical leaf-area profiles" & results$Metric2=="95% CI","Litter_R2"] <- paste("(",round(LitterQuantiles[LitterQuantiles$components=="r","lower"],2),",",round(LitterQuantiles[LitterQuantiles$components=="r","upper"],2),")",sep="")
  results[results$Metric=="Vertical leaf-area profiles" & results$Metric2=="95% CI","Litter_slope"] <- paste("(",round(LitterQuantiles[LitterQuantiles$components=="slope","lower"],2),",",round(LitterQuantiles[LitterQuantiles$components=="slope","upper"],2),")",sep="")
  results[results$Metric=="Vertical leaf-area profiles" & results$Metric2=="95% CI","Wood_R2"] <- paste("(",round(WoodQuantiles[WoodQuantiles$components=="r","lower"],2),",",round(WoodQuantiles[WoodQuantiles$components=="r","upper"],2),")",sep="")
  results[results$Metric=="Vertical leaf-area profiles" & results$Metric2=="95% CI","Wood_slope"] <- paste("(",round(WoodQuantiles[WoodQuantiles$components=="slope","lower"],2),",",round(WoodQuantiles[WoodQuantiles$components=="slope","upper"],2),")",sep="")
  

  results[results$Metric=="Total leaf area" & results$Metric2=="median","ANPP_R2"] <- round(TotalLAIQuantiles[TotalLAIQuantiles$components=="r","median"],2)
  results[results$Metric=="Total leaf area" & results$Metric2=="median","ANPP_slope"] <- round(TotalLAIQuantiles[TotalLAIQuantiles$components=="slope","median"],2)
  results[results$Metric=="Total leaf area" & results$Metric2=="median","Litter_R2"] <- round(LitterLAIQuantiles[LitterLAIQuantiles$components=="r","median"],2)
  results[results$Metric=="Total leaf area" & results$Metric2=="median","Litter_slope"] <- round(LitterLAIQuantiles[LitterLAIQuantiles$components=="slope","median"],2)
  results[results$Metric=="Total leaf area" & results$Metric2=="median","Wood_R2"] <- round(WoodLAIQuantiles[WoodLAIQuantiles$components=="r","median"],2)
  results[results$Metric=="Total leaf area" & results$Metric2=="median","Wood_slope"] <- round(WoodLAIQuantiles[WoodLAIQuantiles$components=="slope","median"],2)
  
    results[results$Metric=="Total leaf area" & results$Metric2=="95% CI","ANPP_R2"] <- paste("(",round(TotalLAIQuantiles[TotalLAIQuantiles$components=="r","lower"],2),",",round(TotalLAIQuantiles[TotalLAIQuantiles$components=="r","upper"],2),")",sep="")
  results[results$Metric=="Total leaf area" & results$Metric2=="95% CI","ANPP_slope"] <- paste("(",round(TotalLAIQuantiles[TotalLAIQuantiles$components=="slope","lower"],2),",",round(TotalLAIQuantiles[TotalLAIQuantiles$components=="slope","upper"],2),")",sep="")
  results[results$Metric=="Total leaf area" & results$Metric2=="95% CI","Litter_R2"] <- paste("(",round(LitterLAIQuantiles[LitterLAIQuantiles$components=="r","lower"],2),",",round(LitterLAIQuantiles[LitterLAIQuantiles$components=="r","upper"],2),")",sep="")
  results[results$Metric=="Total leaf area" & results$Metric2=="95% CI","Litter_slope"] <- paste("(",round(LitterLAIQuantiles[LitterLAIQuantiles$components=="slope","lower"],2),",",round(LitterLAIQuantiles[LitterLAIQuantiles$components=="slope","upper"],2),")",sep="")
  results[results$Metric=="Total leaf area" & results$Metric2=="95% CI","Wood_R2"] <- paste("(",round(WoodLAIQuantiles[WoodLAIQuantiles$components=="r","lower"],2),",",round(WoodLAIQuantiles[WoodLAIQuantiles$components=="r","upper"],2),")",sep="")
  results[results$Metric=="Total leaf area" & results$Metric2=="95% CI","Wood_slope"] <- paste("(",round(WoodLAIQuantiles[WoodLAIQuantiles$components=="slope","lower"],2),",",round(WoodLAIQuantiles[WoodLAIQuantiles$components=="slope","upper"],2),")",sep="")
  
  results[results$Metric=="DRH percentiles" & results$Metric2=="median","ANPP_R2"] <- round(TotalRHQuantiles[TotalRHQuantiles$components=="r","median"],2)
  results[results$Metric=="DRH percentiles" & results$Metric2=="median","ANPP_slope"] <- round(TotalRHQuantiles[TotalRHQuantiles$components=="slope","median"],2)
  results[results$Metric=="DRH percentiles" & results$Metric2=="median","Litter_R2"] <- round(LitterRHQuantiles[LitterRHQuantiles$components=="r","median"],2)
  results[results$Metric=="DRH percentiles" & results$Metric2=="median","Litter_slope"] <- round(LitterRHQuantiles[LitterRHQuantiles$components=="slope","median"],2)
  results[results$Metric=="DRH percentiles" & results$Metric2=="median","Wood_R2"] <- round(WoodRHQuantiles[WoodRHQuantiles$components=="r","median"],2)
  results[results$Metric=="DRH percentiles" & results$Metric2=="median","Wood_slope"] <- round(WoodRHQuantiles[WoodRHQuantiles$components=="slope","median"],2)

    results[results$Metric=="DRH percentiles" & results$Metric2=="95% CI","ANPP_R2"] <- paste("(",round(TotalRHQuantiles[TotalRHQuantiles$components=="r","lower"],2),",",round(TotalRHQuantiles[TotalRHQuantiles$components=="r","upper"],2),")",sep="")
  results[results$Metric=="DRH percentiles" & results$Metric2=="95% CI","ANPP_slope"] <- paste("(",round(TotalRHQuantiles[TotalRHQuantiles$components=="slope","lower"],2),",",round(TotalRHQuantiles[TotalRHQuantiles$components=="slope","upper"],2),")",sep="")
  results[results$Metric=="DRH percentiles" & results$Metric2=="95% CI","Litter_R2"] <- paste("(",round(LitterRHQuantiles[LitterRHQuantiles$components=="r","lower"],2),",",round(LitterRHQuantiles[LitterRHQuantiles$components=="r","upper"],2),")",sep="")
  results[results$Metric=="DRH percentiles" & results$Metric2=="95% CI","Litter_slope"] <- paste("(",round(LitterRHQuantiles[LitterRHQuantiles$components=="slope","lower"],2),",",round(LitterRHQuantiles[LitterRHQuantiles$components=="slope","upper"],2),")",sep="")
  results[results$Metric=="DRH percentiles" & results$Metric2=="95% CI","Wood_R2"] <- paste("(",round(WoodRHQuantiles[WoodRHQuantiles$components=="r","lower"],2),",",round(WoodRHQuantiles[WoodRHQuantiles$components=="r","upper"],2),")",sep="")
  results[results$Metric=="DRH percentiles" & results$Metric2=="95% CI","Wood_slope"] <- paste("(",round(WoodRHQuantiles[WoodRHQuantiles$components=="slope","lower"],2),",",round(WoodRHQuantiles[WoodRHQuantiles$components=="slope","upper"],2),")",sep="")
  
  write.csv(results,"Table 1.csv",row.names = F)
```

```{r Figure 1, include=FALSE, eval=F}

tile <- paste(plots[10], "_2009.las", sep="")
    data <- rLiDAR::readLAS(tile, short=F)
    ground <- raster::extract(DTMraster, data[,1:2])
    data <- cbind(data,rep(NA,length(data[,1])))
    data[,14] <- data[,3] - ground
    
    coords <- L4@polygons[[1]]@Polygons[[1]]@coords
    
    data[,1] <- data[,1]-coords[1,1]
    data[,2] <- data[,2]-coords[1,2]

    coords_t <- coords[1:4,]
    
    
    coords_t[,1] <- coords[1:4,1]-coords[1,1]
    coords_t[,2] <- coords[1:4,2]-coords[1,2]
    
    theta <- atan(abs(coords_t[4,2])/abs(coords_t[4,1]))
    
    t_matrix <- matrix(data=c(cos(theta),-sin(theta),sin(theta),cos(theta)),nrow=2,byrow=T)
    data_matrix <- t(data[,c(1:2)])
    
    new_coords <- t(t_matrix %*% t(data[,c(1:2)]))
    
    new_coords_t <- new_coords
    new_coords_t[,1] <- new_coords[,1]-min(new_coords[,1])
    new_coords_t[,2] <- new_coords[,2]-min(new_coords[,2])
    
    header <- readlasheader(tile)
  
    writelas(file= paste("Plot points for figure.las"), header=header, 
             X=new_coords_t[,1],Y=new_coords_t[,2],Z=data[,14],
             ReturnNumber=data[,5],Classification=data[,9], ScanAngle=data[,10])
    
  
  LAIprofile <- leaf_area_density(z0=data[,14],
                                R=data[,5],
                                A=data[,10],
                                zi=seq(60,1),
                                tl='spherical',
                                n=NULL)
  DRHquantiles <- quantile(data[,14], probs=seq(from=0,to=1,length.out=60))
  
  AxisSz <- 0.9
  AxisTxt <- 1.1
  
pdf("Figure 1_template.pdf", width = 7, height = 3.8)


  
  screens <- rbind(c(0, 0.55, 0, 1), 
                   c(0.55,0.775,0,1),
                   c(0.775, 1, 0, 1)) 
  
  split.screen(screens)
  


  screen(2)
  par(family="serif", oma=c(6.5,1,3,1), mar=c(0,1,0,2))
  
  plot(x=LAIprofile[16:60],
       y=45:1,
       type="l",
       bty="L",
       lwd=2,
       xlab=NA,
       ylab=NA,
       xaxt='n',
       yaxt='n',
       xlim=c(0,0.25),
       ylim=c(0,45))
  mtext(expression(Leaf~area~(m^{2}/m^{2})), side=1, line=3, cex=AxisSz)
  text(x=-0.023, y=44, labels="Total leaf area ",cex=0.8, pos=4)
  text(x=0.03, y=39, labels=paste("=", round(sum(LAIprofile,na.rm=T),1)),cex=0.9, pos=4)
  axis(side=1, at=c(0,0.1,0.2), labels=T, cex.axis=AxisSz)
  axis(side=2, at=c(0,10,20,30,40), labels=c(0,NA,20,NA,40), cex.axis=AxisSz)
  
  screen(3)
  par(family="serif", oma=c(6.5,1,3,1), mar=c(0,1,0,2))
  
  plot(x=seq(from=0,to=100,length.out=60),
       y=DRHquantiles,
       type="l",
       bty="L",
       lwd=2,
       xlab=NA,
       ylab=NA,
       xaxt='n',
       yaxt='n',
       xlim=c(0,100),
       ylim=c(0,45))
  mtext(expression(DRH~quantile~("%")), side=1, line=3, cex=AxisSz) 
  axis(side=1, at=c(0,25,50,75,100), labels=c(0,NA,50,NA,100), cex.axis=AxisSz) 
  axis(side=2, at=c(0,10,20,30,40), labels=c(0,NA,20,NA,40), cex.axis=AxisSz) 
  
  
  close.screen(all = TRUE)

dev.off()


```

```{r Figure 2, include=FALSE, eval=T}

# Define colors to be used in plots
  PlotCols <- c("#F0EA73", #1 yellow
                "#D15B5B", #2 salmon
                "#517FE8", #3 blue
                "#8D8D8D", #4 grey
                "#39A23F", #5 green
                "#E066C4", #6 pink
                "#E98628", #7 gold
                "#8355B8") #8 purple
# Define colors for plot edaphic classes
  A.color <- "#4591A3" #alluvial
  L.color <- "#8B6443" #plateau
  P.color <- "#B8254D" #slope


# Define plot parameters
  PointSz <- 1
  TextSz <- 1.2
  LabSz <- 1
  AxisSz <- 1.5

# Open tiff plot
  pdf("Figure 2.pdf",width=7,height=7.5)
  par(mfrow=c(3,3), mar=c(4,4,3,1),oma=c(1,1,1,1), family="serif", xpd=F)

    # PLOT A - predicted vs observed values for ANPP predicted by leaf-area profiles
      # Create blank plot, then add points by edaphic class and a 1-1 line.
      plot(TotalValuesObserved~TotalValuesPredicted, type='n',
           xlab=NA,ylab=NA,
           cex.lab=TextSz,
           xlim=c(7,17), ylim=c(7,17),
           xaxt='n', yaxt='n')
      axis(side=1, at=c(8,12,16), cex.axis=AxisSz)
      axis(side=2, at=c(8,12,16), cex.axis=AxisSz)
      points(x=TotalValuesPredicted[TestPlotIDs=="A"], y=TotalValuesObserved[TestPlotIDs=="A"],
             pch=16, col=adjustcolor(A.color,alpha.f=0.02))
      points(x=TotalValuesPredicted[TestPlotIDs=="L"], y=TotalValuesObserved[TestPlotIDs=="L"],
             pch=16, col=adjustcolor(L.color,alpha.f=0.02))
      points(x=TotalValuesPredicted[TestPlotIDs=="P"], y=TotalValuesObserved[TestPlotIDs=="P"],
             pch=16, col=adjustcolor(P.color,alpha.f=0.02))
      abline(a=0,b=1,lty=2)
      mtext(expression(Observed~ANPP~(Mg~ha^{-1}~yr^{-1})), side=2, line=2, cex=LabSz)
      mtext(expression(Predicted~ANPP~(Mg~ha^{-1}~yr^{-1})), side=1, line=2.5, cex=LabSz)
      text("A", x=7.1, y=16.8, cex=TextSz)
    
    legend(x=6.8,y=17.2,
      c("Alluvial", "Plateau","Slope"),
      col=c(A.color,L.color, P.color),
      bty='n', cex=TextSz, pch=20, pt.cex=1.5)
            
    # PLOT B- histogram of r values between observed ANPP and ANPP predicted by leaf-area profiles
    hist(TotalRpt$r,
         main=NA,
         col='black', border="white",
         xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,300),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=TotalQuantiles[TotalQuantiles$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=TotalQuantiles[TotalQuantiles$components=="r",c("median")], col=PlotCols[5], lwd=2)
    text("B", x=-0.04, y=290, cex=TextSz)

    # PLOT C- histogram of slope values between observed ANPP and ANPP predicted by leaf-area profiles
    hist(TotalRpt$slope,
         main=NA,
         col='black', border="white",
         cex.lab=TextSz,
         xlim=c(-3,11),breaks=seq(-200000,200000,0.5),
         ylim=c(0,300),
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(Slope), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(-3,-1,1,3,5,7,9,11), labels=c(-3,NA,1,NA,5,NA,9,NA), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=TotalQuantiles[TotalQuantiles$components=="slope",c("median")], col=PlotCols[5], lwd=2)
    text("C", x=-2.9, y=290, cex=TextSz)
    
  
    # PLOT D- predicted vs observed values for ANPP predicted by total leaf area.
      # Create blank plot, then add points by edaphic class and a 1-1 line.
    plot(TotalValuesObserved~TotalValuesPredictedLAI, type='n',
         xlab=NA,
         ylab=NA,
         cex.lab=TextSz,
         xlim=c(7,17), ylim=c(7,17),
         xaxt='n', yaxt='n')
    axis(side=1, at=c(8,12,16), cex.axis=AxisSz)
    axis(side=2, at=c(8,12,16), cex.axis=AxisSz)
    points(x=TotalValuesPredictedLAI[TestPlotIDs=="A"], y=TotalValuesObserved[TestPlotIDs=="A"],
           pch=16, col=adjustcolor(A.color,alpha.f=0.02))
    points(x=TotalValuesPredictedLAI[TestPlotIDs=="L"], y=TotalValuesObserved[TestPlotIDs=="L"],
           pch=16, col=adjustcolor(L.color,alpha.f=0.02))
    points(x=TotalValuesPredictedLAI[TestPlotIDs=="P"], y=TotalValuesObserved[TestPlotIDs=="P"],
           pch=16, col=adjustcolor(P.color,alpha.f=0.02))
    abline(a=0,b=1,lty=2)
    mtext(expression(Observed~ANPP~(Mg~ha^{-1}~yr^{-1})), side=2, line=2, cex=LabSz)
    mtext(expression(Predicted~ANPP~(Mg~ha^{-1}~yr^{-1})), side=1, line=2.5, cex=LabSz)
    text("D", x=7.1, y=16.8, cex=TextSz)


    # PLOT E- histogram of r values between observed ANPP and ANPP predicted by total leaf area
    hist(TotalLAIRpt$r,
         main=NA,
         col='black', border="white",
         xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,300),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=TotalLAIQuantiles[TotalLAIQuantiles$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=TotalLAIQuantiles[TotalLAIQuantiles$components=="r",c("median")], col=PlotCols[5], lwd=3)
    text("E", x=-0.04, y=290, cex=TextSz)
    
    # PLOT F- histogram of slope values between observed ANPP and ANPP predicted by total leaf area
    hist(TotalLAIRpt$slope,
         main=NA,
         col='black', border="white",
         cex.lab=TextSz,
         xlim=c(-3,11),breaks=seq(-200000,200000,0.5),
         ylim=c(0,300),
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(Slope), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(-3,-1,1,3,5,7,9,11), labels=c(-3,NA,1,NA,5,NA,9,NA), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=TotalLAIQuantiles[TotalLAIQuantiles$components=="slope",c("median")], col=PlotCols[5], lwd=2)
    text("F", x=-2.9, y=290, cex=TextSz)
    
    # PLOT G- predicted vs observed values for ANPP predicted by lidar DRH profiles.
      # Create blank plot, then add points by edaphic class and a 1-1 line.
     plot(TotalValuesObserved~TotalValuesPredictedRH, type='n',
         xlab=NA,
         ylab=NA,
         cex.lab=TextSz,
         xlim=c(7,17), ylim=c(7,17),
         xaxt='n', yaxt='n')
    axis(side=1, at=c(8,12,16), cex.axis=AxisSz)
    axis(side=2, at=c(8,12,16), cex.axis=AxisSz)
    points(x=TotalValuesPredictedRH[TestPlotIDs=="A"], y=TotalValuesObserved[TestPlotIDs=="A"],
           pch=16, col=adjustcolor(A.color,alpha.f=0.02))
    points(x=TotalValuesPredictedRH[TestPlotIDs=="L"], y=TotalValuesObserved[TestPlotIDs=="L"],
           pch=16, col=adjustcolor(L.color,alpha.f=0.02))
    points(x=TotalValuesPredictedRH[TestPlotIDs=="P"], y=TotalValuesObserved[TestPlotIDs=="P"],
           pch=16, col=adjustcolor(P.color,alpha.f=0.02))
    abline(a=0,b=1,lty=2)
    mtext(expression(Observed~ANPP~(Mg~ha^{-1}~yr^{-1})), side=2, line=2, cex=LabSz)
    mtext(expression(Predicted~ANPP~(Mg~ha^{-1}~yr^{-1})), side=1, line=2.5, cex=LabSz)
    text("G", x=7.1, y=16.8, cex=TextSz)

    # PLOT H- histogram of r values between observed ANPP and ANPP predicted by lidar DRH profiles.
    hist(TotalRHRpt$r,
         main=NA,
         col='black', border="white",
         xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,300),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=TotalRHQuantiles[TotalRHQuantiles$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=TotalRHQuantiles[TotalRHQuantiles$components=="r",c("median")], col=PlotCols[5], lwd=2)
    text("H", x=-0.04, y=290, cex=TextSz)
    
    # PLOT I- histogram of slope values between observed ANPP and ANPP predicted by lidar DRH profiles.
    hist(TotalRHRpt$slope,
         main=NA,
         col='black', border="white",
         cex.lab=TextSz,
         xlim=c(-3,11),breaks=seq(-200000,200000,0.5),
         ylim=c(0,300),
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(Slope), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(-3,-1,1,3,5,7,9,11), labels=c(-3,NA,1,NA,5,NA,9,NA), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=TotalRHQuantiles[TotalLAIQuantiles$components=="slope",c("median")], col=PlotCols[5], lwd=2)
    text("I", x=-2.9, y=290, cex=TextSz)
    
    mtext("ANPP predicted from vertical leaf-area profiles", side=3, outer=T, cex=TextSz, line=-2)
    mtext("ANPP predicted from total leaf area", side=3, outer=T, cex=TextSz, line=-20)
    mtext("ANPP predicted from LiDAR discrete relative heights", side=3, outer=T, cex=TextSz, line=-39)
    
dev.off()

```

```{r Figure 3, include=FALSE, eval=T}
# Define plot parameters
  PointSz <- 1.5
  TextSz <- 1.2
  LineSz <- 2
  
# Calculate mean and SD of leaf area with height across the 18 CARBONO plots
  LAI.average <- data.frame(Height=heights,
                            MeanLeafArea=NA,
                            SDLeafArea=NA)
  
  for(i in 1:length(LAI.average$Height)){
    LAI.average$MeanLeafArea[i] <- mean(CARBONO$LAI[,i])
    LAI.average$SDLeafArea[i] <- sd(CARBONO$LAI[,i])
  }  
  
# Open tiff plot
  pdf("Figure 3.pdf", width=7,height=4)
  par(mfrow=c(1,2), mar=c(4,4,3,1),oma=c(2,2,1,1), family="serif", xpd=F)
  
  # Plot the mean total loading (3 components combined, weighted by variance explained) for each canopy height position, then plot 95% CI intervals.  
    plot(height~mean, data=TotalWeightsSummary,
         type='l',lwd=2, bty='L',
         xlab="Combined loading weight",
         cex.lab=TextSz, cex.axis=TextSz,
         xlim=range(c(TotalWeightsSummary$min, TotalWeightsSummary$max)),
         ylab=NA)
    points(height~mean, data=TotalWeightsSummary, pch=20)
    arrows(x0=TotalWeightsSummary$min, x1=TotalWeightsSummary$max, 
           y0=TotalWeightsSummary$height, y1=TotalWeightsSummary$height,
           angle=90, length=0.02, code=3)
    abline(v=0, col="red")
    text("A", x=-31, y=60, cex=TextSz)
    
    
    # Plot the mean and SD of leaf area for each canopy height position.  
    plot(Height~MeanLeafArea, data=LAI.average,
         type='l',lwd=2, bty='L',
         xlab=expression(Leaf~area~(m^{2}/m^{2})),
         ylab=NA,
         cex.lab=TextSz, cex.axis=TextSz,
         xlim=c(min(LAI.average$MeanLeafArea-LAI.average$SDLeafArea),max(LAI.average$MeanLeafArea+LAI.average$SDLeafArea)))
    points(Height~MeanLeafArea, data=LAI.average, pch=20)
    arrows(x0=LAI.average$MeanLeafArea-LAI.average$SDLeafArea, x1=LAI.average$MeanLeafArea+LAI.average$SDLeafArea, 
           y0=LAI.average$Height, y1=LAI.average$Height,
           angle=90, length=0.02, code=3)
    text("B", x=-0.01, y=60, cex=TextSz)
    
    mtext("Height (m)", side=2, outer=T, cex=TextSz, line=-1)
    
  dev.off()
```

```{r Figure S1, include=FALSE, eval=T}

# Results Figure S6- Repeat Figure 1 from main text, but for alternate plot sampling method.

  # Define colors to be used in plots
  PlotCols <- c("#F0EA73", #1 yellow
                "#D15B5B", #2 salmon
                "#517FE8", #3 blue
                "#8D8D8D", #4 grey
                "#39A23F", #5 green
                "#E066C4", #6 pink
                "#E98628", #7 gold
                "#8355B8") #8 purple
# Define colors for plot edaphic classes
  A.color <- "#4591A3" #alluvial
  L.color <- "#8B6443" #plateau
  P.color <- "#B8254D" #slope


# Define plot parameters
  PointSz <- 1
  TextSz <- 1.2
  LabSz <- 1
  AxisSz <- 1.5

# Open tiff plot
  tiff("Figure S1.tiff",width=7,height=7.5,units = 'in', res = 300)
  par(mfrow=c(3,3), mar=c(4,4,3,1),oma=c(1,1,1,1), family="serif", xpd=F)

    # PLOT A - predicted vs observed values for ANPP predicted by leaf-area profiles
      # Create blank plot, then add points by edaphic class and a 1-1 line.
      plot(TotalValuesObserved.alt~TotalValuesPredicted.alt, type='n',
           xlab=NA,ylab=NA,
           cex.lab=TextSz,
           xlim=c(7,17), ylim=c(7,17),
           xaxt='n', yaxt='n')
      axis(side=1, at=c(8,12,16), cex.axis=AxisSz)
      axis(side=2, at=c(8,12,16), cex.axis=AxisSz)
      points(x=TotalValuesPredicted.alt[TestPlotIDs=="A"], y=TotalValuesObserved.alt[TestPlotIDs=="A"],
             pch=16, col=adjustcolor(A.color,alpha.f=0.02))
      points(x=TotalValuesPredicted.alt[TestPlotIDs=="L"], y=TotalValuesObserved.alt[TestPlotIDs=="L"],
             pch=16, col=adjustcolor(L.color,alpha.f=0.02))
      points(x=TotalValuesPredicted.alt[TestPlotIDs=="P"], y=TotalValuesObserved.alt[TestPlotIDs=="P"],
             pch=16, col=adjustcolor(P.color,alpha.f=0.02))
      abline(a=0,b=1,lty=2)
      mtext(expression(Observed~ANPP~(Mg~ha^{-1}~yr^{-1})), side=2, line=2, cex=LabSz)
      mtext(expression(Predicted~ANPP~(Mg~ha^{-1}~yr^{-1})), side=1, line=2.5, cex=LabSz)
    
    legend(x=6.8,y=17.2,
      c("Alluvial", "Plateau","Slope"),
      col=c(A.color,L.color, P.color),
      bty='n', cex=TextSz, pch=20, pt.cex=1.5)
            
    # PLOT B- histogram of r values between observed ANPP and ANPP predicted by leaf-area profiles
    hist(TotalRpt.alt$r,
         main=NA,
         col='black', border="white",
         xlim=c(0,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,300),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=TotalQuantiles.alt[TotalQuantiles.alt$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=TotalQuantiles.alt[TotalQuantiles.alt$components=="r",c("median")], col=PlotCols[5], lwd=2)

    # PLOT C- histogram of slope values between observed ANPP and ANPP predicted by leaf-area profiles
    hist(TotalRpt.alt$slope,
         main=NA,
         col='black', border="white",
         cex.lab=TextSz,
         xlim=c(-3,11),breaks=seq(-200000,200000,0.5),
         ylim=c(0,300),
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(Slope), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(-3,-1,1,3,5,7,9,11), labels=c(-3,NA,1,NA,5,NA,9,NA), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=TotalQuantiles.alt[TotalQuantiles.alt$components=="slope",c("median")], col=PlotCols[5], lwd=2)
    
  
    # PLOT D- predicted vs observed values for ANPP predicted by total leaf area.
      # Create blank plot, then add points by edaphic class and a 1-1 line.
    plot(TotalValuesObserved.alt~TotalValuesPredicted.altLAI, type='n',
         xlab=NA,
         ylab=NA,
         cex.lab=TextSz,
         xlim=c(7,17), ylim=c(7,17),
         xaxt='n', yaxt='n')
    axis(side=1, at=c(8,12,16), cex.axis=AxisSz)
    axis(side=2, at=c(8,12,16), cex.axis=AxisSz)
    points(x=TotalValuesPredicted.altLAI[TestPlotIDs=="A"], y=TotalValuesObserved.alt[TestPlotIDs=="A"],
           pch=16, col=adjustcolor(A.color,alpha.f=0.02))
    points(x=TotalValuesPredicted.altLAI[TestPlotIDs=="L"], y=TotalValuesObserved.alt[TestPlotIDs=="L"],
           pch=16, col=adjustcolor(L.color,alpha.f=0.02))
    points(x=TotalValuesPredicted.altLAI[TestPlotIDs=="P"], y=TotalValuesObserved.alt[TestPlotIDs=="P"],
           pch=16, col=adjustcolor(P.color,alpha.f=0.02))
    abline(a=0,b=1,lty=2)
    mtext(expression(Observed~ANPP~(Mg~ha^{-1}~yr^{-1})), side=2, line=2, cex=LabSz)
    mtext(expression(Predicted~ANPP~(Mg~ha^{-1}~yr^{-1})), side=1, line=2.5, cex=LabSz)
    


    # PLOT E- histogram of r values between observed ANPP and ANPP predicted by total leaf area
    hist(TotalLAIRpt.alt$r,
         main=NA,
         col='black', border="white",
         xlim=c(0,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,300),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=TotalLAIQuantiles.alt[TotalLAIQuantiles.alt$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=TotalLAIQuantiles.alt[TotalLAIQuantiles.alt$components=="r",c("median")], col=PlotCols[5], lwd=3)
    
    # PLOT F- histogram of slope values between observed ANPP and ANPP predicted by total leaf area
    hist(TotalLAIRpt.alt$slope,
         main=NA,
         col='black', border="white",
         cex.lab=TextSz,
         xlim=c(-3,11),breaks=seq(-200000,200000,0.5),
         ylim=c(0,300),
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(Slope), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(-3,-1,1,3,5,7,9,11), labels=c(-3,NA,1,NA,5,NA,9,NA), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=TotalLAIQuantiles.alt[TotalLAIQuantiles.alt$components=="slope",c("median")], col=PlotCols[5], lwd=2)
    
    # PLOT G- predicted vs observed values for ANPP predicted by lidar DRH profiles.
      # Create blank plot, then add points by edaphic class and a 1-1 line.
     plot(TotalValuesObserved.alt~TotalValuesPredicted.altRH, type='n',
         xlab=NA,
         ylab=NA,
         cex.lab=TextSz,
         xlim=c(7,17), ylim=c(7,17),
         xaxt='n', yaxt='n')
    axis(side=1, at=c(8,12,16), cex.axis=AxisSz)
    axis(side=2, at=c(8,12,16), cex.axis=AxisSz)
    points(x=TotalValuesPredicted.altRH[TestPlotIDs=="A"], y=TotalValuesObserved.alt[TestPlotIDs=="A"],
           pch=16, col=adjustcolor(A.color,alpha.f=0.02))
    points(x=TotalValuesPredicted.altRH[TestPlotIDs=="L"], y=TotalValuesObserved.alt[TestPlotIDs=="L"],
           pch=16, col=adjustcolor(L.color,alpha.f=0.02))
    points(x=TotalValuesPredicted.altRH[TestPlotIDs=="P"], y=TotalValuesObserved.alt[TestPlotIDs=="P"],
           pch=16, col=adjustcolor(P.color,alpha.f=0.02))
    abline(a=0,b=1,lty=2)
    mtext(expression(Observed~ANPP~(Mg~ha^{-1}~yr^{-1})), side=2, line=2, cex=LabSz)
    mtext(expression(Predicted~ANPP~(Mg~ha^{-1}~yr^{-1})), side=1, line=2.5, cex=LabSz)

    # PLOT H- histogram of r values between observed ANPP and ANPP predicted by lidar DRH profiles.
    hist(TotalRHRpt.alt$r,
         main=NA,
         col='black', border="white",
         xlim=c(0,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,300),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=TotalRHQuantiles.alt[TotalRHQuantiles.alt$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=TotalRHQuantiles.alt[TotalRHQuantiles.alt$components=="r",c("median")], col=PlotCols[5], lwd=2)
    
    # PLOT I- histogram of slope values between observed ANPP and ANPP predicted by lidar DRH profiles.
    hist(TotalRHRpt.alt$slope,
         main=NA,
         col='black', border="white",
         cex.lab=TextSz,
         xlim=c(-3,11),breaks=seq(-200000,200000,0.5),
         ylim=c(0,300),
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(Slope), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(-3,-1,1,3,5,7,9,11), labels=c(-3,NA,1,NA,5,NA,9,NA), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=TotalRHQuantiles.alt[TotalLAIQuantiles.alt$components=="slope",c("median")], col=PlotCols[5], lwd=2)
    
    mtext("ANPP predicted from vertical leaf-area profiles", side=3, outer=T, cex=TextSz, line=-2)
    mtext("ANPP predicted from total leaf area", side=3, outer=T, cex=TextSz, line=-20)
    mtext("ANPP predicted from LiDAR discrete relative heights", side=3, outer=T, cex=TextSz, line=-39)
    
dev.off()


```

```{r Figure S2, include=FALSE, eval=T}

PlotCols <- c("#F0EA73", #1 yellow
              "#D15B5B", #2 salmon
              "#517FE8", #3 blue
              "#8D8D8D", #4 grey
              "#39A23F", #5 green
              "#E066C4", #6 pink
              "#E98628", #7 gold
              "#8355B8") #8 purple

A.color <- "#4591A3" #alluvial
L.color <- "#8B6443" #plateau
P.color <- "#B8254D" #slope

  PointSz <- 1
  TextSz <- 1.2
  LabSz <- 0.9
  AxisSz <- 1.5
  
  
  tiff(width=7,height=7.5,file="Figure S2.tiff",units="in", res=300)
  par(mfrow=c(3,3), mar=c(4,4,3,1),oma=c(1,1,1,1), family="serif", xpd=F)
  
  
      # PLOT A
      plot(LitterValuesObserved.alt~LitterValuesPredicted.alt, type='n',
           xlab=NA,ylab=NA,
           cex.lab=TextSz,
           xlim=c(4,12), ylim=c(4,12),
           xaxt='n', yaxt='n')
      axis(side=1, at=c(4,8,12), cex.axis=AxisSz)
      axis(side=2, at=c(4,8,12), cex.axis=AxisSz)
      points(x=LitterValuesPredicted.alt[TestPlotIDs=="A"], y=LitterValuesObserved.alt[TestPlotIDs=="A"],
             pch=16, col=adjustcolor(A.color,alpha.f=0.02))
      points(x=LitterValuesPredicted.alt[TestPlotIDs=="L"], y=LitterValuesObserved.alt[TestPlotIDs=="L"],
             pch=16, col=adjustcolor(L.color,alpha.f=0.02))
      points(x=LitterValuesPredicted.alt[TestPlotIDs=="P"], y=LitterValuesObserved.alt[TestPlotIDs=="P"],
             pch=16, col=adjustcolor(P.color,alpha.f=0.02))
      abline(a=0,b=1,lty=2)
      mtext(expression(Observed.alt~Litterfall~(Mg~ha^{-1}~yr^{-1})), side=2, line=2, cex=LabSz)
      mtext(expression(Predicted.alt~Litterfall~(Mg~ha^{-1}~yr^{-1})), side=1, line=2.5, cex=LabSz)
      
      legend(x=4,y=12,
        c("Alluvial", "Plateau","Slope"),
        col=c(A.color,L.color, P.color),
        bty='n', cex=TextSz, pch=20, pt.cex=1.5)
              
    # PLOT B- histogram of r values between observed ANPP and ANPP predicted by leaf-area profiles
    hist(LitterRpt.alt$r,
         main=NA,
         col='black', border="white",
         xlim=c(0,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,250),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,125,250), cex.axis=AxisSz)
    abline(v=LitterQuantiles.alt[LitterQuantiles.alt$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=LitterQuantiles.alt[LitterQuantiles.alt$components=="r",c("median")], col=PlotCols[5], lwd=2)

    # PLOT C- histogram of slope values between observed ANPP and ANPP predicted by leaf-area profiles
    hist(LitterRpt.alt$slope,
         main=NA,
         col='black', border="white",
         cex.lab=TextSz,
         xlim=c(-3,11),breaks=seq(-200000,200000,0.5),
         ylim=c(0,300),
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(Slope), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(-3,-1,1,3,5,7,9,11), labels=c(-3,NA,1,NA,5,NA,9,NA), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=LitterQuantiles.alt[LitterQuantiles.alt$components=="slope",c("median")], col=PlotCols[5], lwd=2)
      
    
      # PLOT D
      plot(LitterValuesObserved.alt~LitterValuesPredicted.altLAI, type='n',
           xlab=NA,
           ylab=NA,
           cex.lab=TextSz,
           xlim=c(4,12), ylim=c(4,12),
           xaxt='n', yaxt='n')
      axis(side=1, at=c(4,8,12), cex.axis=AxisSz)
      axis(side=2, at=c(4,8,12), cex.axis=AxisSz)
      points(x=LitterValuesPredicted.altLAI[TestPlotIDs=="A"], y=LitterValuesObserved.alt[TestPlotIDs=="A"],
             pch=16, col=adjustcolor(A.color,alpha.f=0.02))
      points(x=LitterValuesPredicted.altLAI[TestPlotIDs=="L"], y=LitterValuesObserved.alt[TestPlotIDs=="L"],
             pch=16, col=adjustcolor(L.color,alpha.f=0.02))
      points(x=LitterValuesPredicted.altLAI[TestPlotIDs=="P"], y=LitterValuesObserved.alt[TestPlotIDs=="P"],
             pch=16, col=adjustcolor(P.color,alpha.f=0.02))
      abline(a=0,b=1,lty=2)
      mtext(expression(Observed.alt~Litterfall~(Mg~ha^{-1}~yr^{-1})), side=2, line=2, cex=LabSz)
      mtext(expression(Predicted.alt~Litterfall~(Mg~ha^{-1}~yr^{-1})), side=1, line=2.5, cex=LabSz)
      
  
    # PLOT E- histogram of r values between observed ANPP and ANPP predicted by total leaf area
    hist(LitterLAIRpt.alt$r,
         main=NA,
         col='black', border="white",
         xlim=c(0,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,250),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,125,250), cex.axis=AxisSz)
    abline(v=LitterLAIQuantiles.alt[LitterLAIQuantiles.alt$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=LitterLAIQuantiles.alt[LitterLAIQuantiles.alt$components=="r",c("median")], col=PlotCols[5], lwd=3)
    
    # PLOT F- histogram of slope values between observed ANPP and ANPP predicted by total leaf area
    hist(LitterLAIRpt.alt$slope,
         main=NA,
         col='black', border="white",
         cex.lab=TextSz,
         xlim=c(-3,11),breaks=seq(-200000,200000,0.5),
         ylim=c(0,300),
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(Slope), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(-3,-1,1,3,5,7,9,11), labels=c(-3,NA,1,NA,5,NA,9,NA), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=LitterLAIQuantiles.alt[LitterLAIQuantiles.alt$components=="slope",c("median")], col=PlotCols[5], lwd=2)
    
      # PLOT G
       plot(LitterValuesObserved.alt~LitterValuesPredicted.altRH, type='n',
           xlab=NA,
           ylab=NA,
           cex.lab=TextSz,
           xlim=c(4,12), ylim=c(4,12),
           xaxt='n', yaxt='n')
      axis(side=1, at=c(4,8,12), cex.axis=AxisSz)
      axis(side=2, at=c(4,8,12), cex.axis=AxisSz)
      points(x=LitterValuesPredicted.altRH[TestPlotIDs=="A"], y=LitterValuesObserved.alt[TestPlotIDs=="A"],
             pch=16, col=adjustcolor(A.color,alpha.f=0.02))
      points(x=LitterValuesPredicted.altRH[TestPlotIDs=="L"], y=LitterValuesObserved.alt[TestPlotIDs=="L"],
             pch=16, col=adjustcolor(L.color,alpha.f=0.02))
      points(x=LitterValuesPredicted.altRH[TestPlotIDs=="P"], y=LitterValuesObserved.alt[TestPlotIDs=="P"],
             pch=16, col=adjustcolor(P.color,alpha.f=0.02))
      abline(a=0,b=1,lty=2)
      mtext(expression(Observed.alt~Litterfall~(Mg~ha^{-1}~yr^{-1})), side=2, line=2, cex=LabSz)
      mtext(expression(Predicted.alt~Litterfall~(Mg~ha^{-1}~yr^{-1})), side=1, line=2.5, cex=LabSz)
  
    # PLOT H- histogram of r values between observed ANPP and ANPP predicted by lidar DRH profiles.
    hist(LitterRHRpt.alt$r,
         main=NA,
         col='black', border="white",
         xlim=c(0,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,250),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,125,250), cex.axis=AxisSz)
    abline(v=LitterRHQuantiles.alt[LitterRHQuantiles.alt$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=LitterRHQuantiles.alt[LitterRHQuantiles.alt$components=="r",c("median")], col=PlotCols[5], lwd=2)
    
    # PLOT I- histogram of slope values between observed ANPP and ANPP predicted by lidar DRH profiles.
    hist(LitterRHRpt.alt$slope,
         main=NA,
         col='black', border="white",
         cex.lab=TextSz,
         xlim=c(-3,11),breaks=seq(-200000,200000,0.5),
         ylim=c(0,300),
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(Slope), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(-3,-1,1,3,5,7,9,11), labels=c(-3,NA,1,NA,5,NA,9,NA), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=LitterRHQuantiles.alt[LitterLAIQuantiles.alt$components=="slope",c("median")], col=PlotCols[5], lwd=2)
      
      mtext("Litter productivity predicted from vertical leaf-area profiles", side=3, outer=T, cex=TextSz, line=-2)
      mtext("Litter productivity predicted from total leaf area", side=3, outer=T, cex=TextSz, line=-20)
      mtext("Litter productivity predicted from LiDAR discrete relative heights", side=3, outer=T, cex=TextSz, line=-39)
      
  dev.off()

```

```{r Figure S3, include=FALSE, eval=T}

PlotCols <- c("#F0EA73", #1 yellow
              "#D15B5B", #2 salmon
              "#517FE8", #3 blue
              "#8D8D8D", #4 grey
              "#39A23F", #5 green
              "#E066C4", #6 pink
              "#E98628", #7 gold
              "#8355B8") #8 purple

A.color <- "#4591A3" #alluvial
L.color <- "#8B6443" #plateau
P.color <- "#B8254D" #slope


# Results Figure S8- Repeat Figure S3, but for alternate plot sampling method.
  PointSz <- 1
  TextSz <- 1.2
  LabSz <- 0.8
  AxisSz <- 1.2
  
  
  tiff("Figure S3.tiff", width=7,height=7.5,units="in",res=300)
  par(mfrow=c(3,3), mar=c(4,4,3,1),oma=c(1,1,1,1), family="serif", xpd=F)
  
  
      # PLOT A
      plot(WoodValuesObserved.alt~WoodValuesPredicted.alt, type='n',
           xlab=NA,ylab=NA,
           cex.lab=TextSz,
           xlim=c(3,7), ylim=c(3,7.5),
           xaxt='n', yaxt='n')
      axis(side=1, at=c(3,5,7), cex.axis=AxisSz)
      axis(side=2, at=c(3,5,7), cex.axis=AxisSz)
      points(x=WoodValuesPredicted.alt[TestPlotIDs=="A"], y=WoodValuesObserved.alt[TestPlotIDs=="A"],
             pch=16, col=adjustcolor(A.color,alpha.f=0.02))
      points(x=WoodValuesPredicted.alt[TestPlotIDs=="L"], y=WoodValuesObserved.alt[TestPlotIDs=="L"],
             pch=16, col=adjustcolor(L.color,alpha.f=0.02))
      points(x=WoodValuesPredicted.alt[TestPlotIDs=="P"], y=WoodValuesObserved.alt[TestPlotIDs=="P"],
             pch=16, col=adjustcolor(P.color,alpha.f=0.02))
      abline(a=0,b=1,lty=2)
      mtext(expression(Observed.alt~Productivity~(Mg~ha^{-1}~yr^{-1})), side=2, line=2, cex=LabSz)
      mtext(expression(Predicted.alt~Productivity~(Mg~ha^{-1}~yr^{-1})), side=1, line=2.5, cex=LabSz)
      
      legend(x=3,y=7,
        c("Alluvial", "Plateau","Slope"),
        col=c(A.color,L.color, P.color),
        bty='n', cex=TextSz, pch=20, pt.cex=1.5)
              
   # PLOT B- histogram of r values between observed ANPP and ANPP predicted by leaf-area profiles
    hist(WoodRpt.alt$r,
         main=NA,
         col='black', border="white",
         xlim=c(0,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,600),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,300,600), cex.axis=AxisSz)
    abline(v=WoodQuantiles.alt[WoodQuantiles.alt$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=WoodQuantiles.alt[WoodQuantiles.alt$components=="r",c("median")], col=PlotCols[5], lwd=2)

    # PLOT C- histogram of slope values between observed ANPP and ANPP predicted by leaf-area profiles
    hist(WoodRpt.alt$slope,
         main=NA,
         col='black', border="white",
         cex.lab=TextSz,
         xlim=c(-7,7),breaks=seq(-200000,200000,0.5),
         ylim=c(0,300),
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(Slope), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(-7,-5,-3,-1,1,3,5,7), labels=c(-7,NA,-3,NA,1,NA,5,NA), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=WoodQuantiles.alt[WoodQuantiles.alt$components=="slope",c("median")], col=PlotCols[5], lwd=2)
    
    # PLOT D
          plot(WoodValuesObserved.alt~WoodValuesPredicted.altLAI, type='n',
           xlab=NA,ylab=NA,
           cex.lab=TextSz,
           xlim=c(3,7), ylim=c(3,7.5),
           xaxt='n', yaxt='n')
      axis(side=1, at=c(3,5,7), cex.axis=AxisSz)
      axis(side=2, at=c(3,5,7), cex.axis=AxisSz)
      points(x=WoodValuesPredicted.altLAI[TestPlotIDs=="A"], y=WoodValuesObserved.alt[TestPlotIDs=="A"],
             pch=16, col=adjustcolor(A.color,alpha.f=0.02))
      points(x=WoodValuesPredicted.altLAI[TestPlotIDs=="L"], y=WoodValuesObserved.alt[TestPlotIDs=="L"],
             pch=16, col=adjustcolor(L.color,alpha.f=0.02))
      points(x=WoodValuesPredicted.altLAI[TestPlotIDs=="P"], y=WoodValuesObserved.alt[TestPlotIDs=="P"],
             pch=16, col=adjustcolor(P.color,alpha.f=0.02))
      abline(a=0,b=1,lty=2)
      mtext(expression(Observed.alt~Productivity~(Mg~ha^{-1}~yr^{-1})), side=2, line=2, cex=LabSz)
      mtext(expression(Predicted.alt~Productivity~(Mg~ha^{-1}~yr^{-1})), side=1, line=2.5, cex=LabSz)
      
      
    # PLOT E- histogram of r values between observed ANPP and ANPP predicted by total leaf area
    hist(WoodLAIRpt.alt$r,
         main=NA,
         col='black', border="white",
         xlim=c(0,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,600),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,300,600), cex.axis=AxisSz)
    abline(v=WoodLAIQuantiles.alt[WoodLAIQuantiles.alt$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=WoodLAIQuantiles.alt[WoodLAIQuantiles.alt$components=="r",c("median")], col=PlotCols[5], lwd=3)
    
    # PLOT F- histogram of slope values between observed ANPP and ANPP predicted by total leaf area
    hist(WoodLAIRpt.alt$slope,
         main=NA,
         col='black', border="white",
         cex.lab=TextSz,
         xlim=c(-7,7),breaks=seq(-200000,200000,0.5),
         ylim=c(0,500),
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(Slope), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(-7,-5,-3,-1,1,3,5,7), labels=c(-7,NA,-3,NA,1,NA,5,NA), cex.axis=AxisSz)
    axis(side=2, at=c(0,250,500), cex.axis=AxisSz)
    abline(v=WoodLAIQuantiles.alt[WoodLAIQuantiles.alt$components=="slope",c("median")], col=PlotCols[5], lwd=2)
  
      # PLOT G
       plot(WoodValuesObserved.alt~WoodValuesPredicted.altRH, type='n',
           xlab=NA,
           ylab=NA,
           cex.lab=TextSz,
           xlim=c(3,7), ylim=c(3,7.5),
           xaxt='n', yaxt='n')
      axis(side=1, at=c(3,5,7), cex.axis=AxisSz)
      axis(side=2, at=c(3,5,7), cex.axis=AxisSz)
      points(x=WoodValuesPredicted.altRH[TestPlotIDs=="A"], y=WoodValuesObserved.alt[TestPlotIDs=="A"],
             pch=16, col=adjustcolor(A.color,alpha.f=0.02))
      points(x=WoodValuesPredicted.altRH[TestPlotIDs=="L"], y=WoodValuesObserved.alt[TestPlotIDs=="L"],
             pch=16, col=adjustcolor(L.color,alpha.f=0.02))
      points(x=WoodValuesPredicted.altRH[TestPlotIDs=="P"], y=WoodValuesObserved.alt[TestPlotIDs=="P"],
             pch=16, col=adjustcolor(P.color,alpha.f=0.02))
      abline(a=0,b=1,lty=2)
      mtext(expression(Observed.alt~Productivity~(Mg~ha^{-1}~yr^{-1})), side=2, line=2, cex=LabSz)
      mtext(expression(Predicted.alt~Productivity~(Mg~ha^{-1}~yr^{-1})), side=1, line=2.5, cex=LabSz)
  
    # PLOT H- histogram of r values between observed ANPP and ANPP predicted by lidar DRH profiles.
    hist(WoodRHRpt.alt$r,
         main=NA,
         col='black', border="white",
         xlim=c(0,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,600),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,300,600), cex.axis=AxisSz)
    abline(v=WoodRHQuantiles.alt[WoodRHQuantiles.alt$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=WoodRHQuantiles.alt[WoodRHQuantiles.alt$components=="r",c("median")], col=PlotCols[5], lwd=2)
    
    # PLOT I- histogram of slope values between observed ANPP and ANPP predicted by lidar DRH profiles.
    hist(WoodRHRpt.alt$slope,
         main=NA,
         col='black', border="white",
         cex.lab=TextSz,
         xlim=c(-7,7),breaks=seq(-200000,200000,0.5),
         ylim=c(0,300),
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(Slope), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(-7,-5,-3,-1,1,3,5,7), labels=c(-7,NA,-3,NA,1,NA,5,NA), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=WoodRHQuantiles.alt[WoodLAIQuantiles.alt$components=="slope",c("median")], col=PlotCols[5], lwd=2)
      
      mtext("Wood productivity predicted from vertical leaf-area profiles", side=3, outer=T, cex=TextSz, line=-2)
      mtext("Wood productivity predicted from total leaf area", side=3, outer=T, cex=TextSz, line=-20)
      mtext("Wood productivity predicted from LiDAR discrete relative heights", side=3, outer=T, cex=TextSz, line=-39)
    
dev.off()

```

```{r Figure S4, include=FALSE, eval=T}

# Compare R^2 of predicting ANPP with wood density and change in gap fraction

tiff("Figure S4.tiff", height=5, width=8, units="in", res=300)  
  par(mfrow=c(1,2), oma=c(2,2,2,0), mar=c(2,2,1,0), family="serif")
  
  TextSz <- 1.2
  LabSz <- 0.9
  AxisSz <- 1.2
  
  # R-squared values
    hist(DensityRpt$r,
           main="Wood density",
           col='black', border="white",
           xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
           ylim=c(0,300),
           cex.lab=TextSz,cex.main=TextSz+0.2,
           xlab=NA,ylab=NA,
           xaxt='n', yaxt='n')
      mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)  
      mtext(expression(Frequency), side=2, line=2, cex=LabSz)
      axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1), cex.axis=AxisSz)
      axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
      abline(v=DensityQuantiles[DensityQuantiles$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
      abline(v=DensityQuantiles[DensityQuantiles$components=="r",c("median")], col=PlotCols[5], lwd=2)
      text("A", x=-0.05, y=300, cex=TextSz)
      
     hist(GapRpt$r,
           main="Change in gap area",
           col='black', border="white",
           xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
           ylim=c(0,300),
           cex.lab=TextSz,cex.main=TextSz+0.2,
           xlab=NA,ylab=NA,
           xaxt='n', yaxt='n')
      mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
      axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1), cex.axis=AxisSz)
      axis(side=2, at=c(0,150,300), labels = NA, cex.axis=AxisSz)
      abline(v=GapQuantiles[GapQuantiles$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
      abline(v=GapQuantiles[GapQuantiles$components=="r",c("median")], col=PlotCols[5], lwd=2)
      text("B", x=-0.05, y=300, cex=TextSz)
      
  dev.off()
  



```

```{r Figure S5, include=FALSE, eval=T}
# Results Figure S4- Repeat Figure 3 from main text, but for litter production PLS model (instead of total ANPP).
  PointSz <- 1.5
  TextSz <- 1.4
  LineSz <- 2
  tiff("Figure S5.tiff", width=7,height=7,units="in",res=300)
  par(mfrow=c(2,2), mar=c(4,4,3,1),oma=c(2,2,1,1), family="serif", xpd=F)
   
  plot(height~mean, data=LitterWeightsSummary,
       type='l',lwd=2, bty='L',
       xlab=NA,
       main="Total weight",
       cex.lab=TextSz, cex.axis=TextSz,
       xlim=range(c(LitterWeightsSummary$min, LitterWeightsSummary$max)),
       ylab=NA)
  points(height~mean, data=LitterWeightsSummary, pch=20)
  arrows(x0=LitterWeightsSummary$min, x1=LitterWeightsSummary$max, 
         y0=LitterWeightsSummary$height, y1=LitterWeightsSummary$height,
         angle=90, length=0.02, code=3)
  abline(v=0, col="red")
  
  plot(height~mean, data=LitterC1LoadingsSummary,
       type='l',lwd=2, bty='L',
       xlab=NA,
       main="Component 1",
       cex.lab=TextSz, cex.axis=TextSz,
       xlim=range(c(LitterC1LoadingsSummary$min, LitterC1LoadingsSummary$max)),
       ylab=NA)
  points(height~mean, data=LitterC1LoadingsSummary, pch=20)
  arrows(x0=LitterC1LoadingsSummary$min, x1=LitterC1LoadingsSummary$max, 
         y0=LitterC1LoadingsSummary$height, y1=LitterC1LoadingsSummary$height,
         angle=90, length=0.02, code=3)
  abline(v=0, col="red")
  
  plot(height~mean, data=LitterC2LoadingsSummary,
       type='l',lwd=2, bty='L',
       xlab=NA,
       main="Component 2",
       cex.lab=TextSz, cex.axis=TextSz,
       xlim=range(c(LitterC2LoadingsSummary$min, LitterC2LoadingsSummary$max)),
       ylab=NA)
  points(height~mean, data=LitterC2LoadingsSummary, pch=20)
  arrows(x0=LitterC2LoadingsSummary$min, x1=LitterC2LoadingsSummary$max, 
         y0=LitterC2LoadingsSummary$height, y1=LitterC2LoadingsSummary$height,
         angle=90, length=0.02, code=3)
  abline(v=0, col="red")
  
  plot(height~mean, data=LitterC3LoadingsSummary,
       type='l',lwd=2, bty='L',
       xlab=NA,
       main="Component 3",
       cex.lab=TextSz, cex.axis=TextSz,
       xlim=range(c(LitterC3LoadingsSummary$min, LitterC3LoadingsSummary$max)),
       ylab=NA)
  points(height~mean, data=LitterC3LoadingsSummary, pch=20)
  arrows(x0=LitterC3LoadingsSummary$min, x1=LitterC3LoadingsSummary$max, 
         y0=LitterC3LoadingsSummary$height, y1=LitterC3LoadingsSummary$height,
         angle=90, length=0.02, code=3)
  abline(v=0, col="red")
  mtext("Height (m)", side=2, outer=T, cex=TextSz)
  mtext("Loading value", side=1, outer=T, cex=TextSz)
  
  dev.off()


```

```{r Figure S6, include=FALSE, eval=T}
# Results Figure S5- Repeat Figure 3 from main text, but for wood production PLS model (instead of total ANPP).
  PointSz <- 1.5
  TextSz <- 1.4
  LineSz <- 2
  tiff("Figure S6.tiff", width=7,height=7,units="in",res=300)
  par(mfrow=c(2,2), mar=c(4,4,3,1),oma=c(2,2,1,1), family="serif", xpd=F)
   
  plot(height~mean, data=WoodWeightsSummary,
       type='l',lwd=2, bty='L',
       xlab=NA,
       main="Total weight",
       cex.lab=TextSz, cex.axis=TextSz,
       xlim=range(c(WoodWeightsSummary$min, WoodWeightsSummary$max)),
       ylab=NA)
  points(height~mean, data=WoodWeightsSummary, pch=20)
  arrows(x0=WoodWeightsSummary$min, x1=WoodWeightsSummary$max, 
         y0=WoodWeightsSummary$height, y1=WoodWeightsSummary$height,
         angle=90, length=0.02, code=3)
  abline(v=0, col="red")
  
  plot(height~mean, data=WoodC1LoadingsSummary,
       type='l',lwd=2, bty='L',
       xlab=NA,
       main="Component 1",
       cex.lab=TextSz, cex.axis=TextSz,
       xlim=range(c(WoodC1LoadingsSummary$min, WoodC1LoadingsSummary$max)),
       ylab=NA)
  points(height~mean, data=WoodC1LoadingsSummary, pch=20)
  arrows(x0=WoodC1LoadingsSummary$min, x1=WoodC1LoadingsSummary$max, 
         y0=WoodC1LoadingsSummary$height, y1=WoodC1LoadingsSummary$height,
         angle=90, length=0.02, code=3)
  abline(v=0, col="red")
  
  plot(height~mean, data=WoodC2LoadingsSummary,
       type='l',lwd=2, bty='L',
       xlab=NA,
       main="Component 2",
       cex.lab=TextSz, cex.axis=TextSz,
       xlim=range(c(WoodC2LoadingsSummary$min, WoodC2LoadingsSummary$max)),
       ylab=NA)
  points(height~mean, data=WoodC2LoadingsSummary, pch=20)
  arrows(x0=WoodC2LoadingsSummary$min, x1=WoodC2LoadingsSummary$max, 
         y0=WoodC2LoadingsSummary$height, y1=WoodC2LoadingsSummary$height,
         angle=90, length=0.02, code=3)
  abline(v=0, col="red")
  
  plot(height~mean, data=WoodC3LoadingsSummary,
       type='l',lwd=2, bty='L',
       xlab=NA,
       main="Component 3",
       cex.lab=TextSz, cex.axis=TextSz,
       xlim=range(c(WoodC3LoadingsSummary$min, WoodC3LoadingsSummary$max)),
       ylab=NA)
  points(height~mean, data=WoodC3LoadingsSummary, pch=20)
  arrows(x0=WoodC3LoadingsSummary$min, x1=WoodC3LoadingsSummary$max, 
         y0=WoodC3LoadingsSummary$height, y1=WoodC3LoadingsSummary$height,
         angle=90, length=0.02, code=3)
  abline(v=0, col="red")
  mtext("Height (m)", side=2, outer=T, cex=TextSz)
  mtext("Loading value", side=1, outer=T, cex=TextSz)
  
  dev.off()
  
```

```{r Figure S7, include=FALSE, eval=T}

tiff("Figure S7.tiff", height=5, width=5, units="in", res=300)  
  par(mfrow=c(1,1), oma=c(2,2,2,0), mar=c(2,2,1,0), family="serif")
  
  TextSz <- 1.2
  LabSz <- 0.9
  AxisSz <- 1.2
  
  # R-squared values
    hist(TotalRpt_sep$r,
           main=NA,
           col='black', border="white",
           xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
           ylim=c(0,300),
           cex.lab=TextSz,cex.main=TextSz+0.2,
           xlab=NA,ylab=NA,
           xaxt='n', yaxt='n')
      mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)  
      mtext(expression(Frequency), side=2, line=2, cex=LabSz)
      axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1), cex.axis=AxisSz)
      axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
      abline(v=TotalQuantiles_sep[TotalQuantiles_sep$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
      abline(v=TotalQuantiles_sep[TotalQuantiles_sep$components=="r",c("median")], col=PlotCols[5], lwd=2)

  dev.off()
  



```

```{r Figure S8, include=FALSE, eval=T}

PlotCols <- c("#F0EA73", #1 yellow
              "#D15B5B", #2 salmon
              "#517FE8", #3 blue
              "#8D8D8D", #4 grey
              "#39A23F", #5 green
              "#E066C4", #6 pink
              "#E98628", #7 gold
              "#8355B8") #8 purple

A.color <- "#4591A3" #alluvial
L.color <- "#8B6443" #plateau
P.color <- "#B8254D" #slope


# Results Figure S2- Repeat Figure 2 from main text, but for litter production results (instead of total ANPP).
  PointSz <- 1
  TextSz <- 1.2
  LabSz <- 0.9
  AxisSz <- 1.5
  
  
  tiff(width=7,height=7.5,file="Figure S8.tiff",units="in", res=300)
  par(mfrow=c(3,3), mar=c(4,4,3,1),oma=c(1,1,1,1), family="serif", xpd=F)
  
  
      # PLOT A
      plot(LitterValuesObserved~LitterValuesPredicted, type='n',
           xlab=NA,ylab=NA,
           cex.lab=TextSz,
           xlim=c(4,12), ylim=c(4,12),
           xaxt='n', yaxt='n')
      axis(side=1, at=c(4,8,12), cex.axis=AxisSz)
      axis(side=2, at=c(4,8,12), cex.axis=AxisSz)
      points(x=LitterValuesPredicted[TestPlotIDs=="A"], y=LitterValuesObserved[TestPlotIDs=="A"],
             pch=16, col=adjustcolor(A.color,alpha.f=0.02))
      points(x=LitterValuesPredicted[TestPlotIDs=="L"], y=LitterValuesObserved[TestPlotIDs=="L"],
             pch=16, col=adjustcolor(L.color,alpha.f=0.02))
      points(x=LitterValuesPredicted[TestPlotIDs=="P"], y=LitterValuesObserved[TestPlotIDs=="P"],
             pch=16, col=adjustcolor(P.color,alpha.f=0.02))
      abline(a=0,b=1,lty=2)
      mtext(expression(Observed~Litterfall~(Mg~ha^{-1}~yr^{-1})), side=2, line=2, cex=LabSz)
      mtext(expression(Predicted~Litterfall~(Mg~ha^{-1}~yr^{-1})), side=1, line=2.5, cex=LabSz)
      
      legend(x=4,y=12,
        c("Alluvial", "Plateau","Slope"),
        col=c(A.color,L.color, P.color),
        bty='n', cex=TextSz, pch=20, pt.cex=1.5)
              
    # PLOT B- histogram of r values between observed ANPP and ANPP predicted by leaf-area profiles
    hist(LitterRpt$r,
         main=NA,
         col='black', border="white",
         xlim=c(0,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,250),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,125,250), cex.axis=AxisSz)
    abline(v=LitterQuantiles[LitterQuantiles$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=LitterQuantiles[LitterQuantiles$components=="r",c("median")], col=PlotCols[5], lwd=2)

    # PLOT C- histogram of slope values between observed ANPP and ANPP predicted by leaf-area profiles
    hist(LitterRpt$slope,
         main=NA,
         col='black', border="white",
         cex.lab=TextSz,
         xlim=c(-3,11),breaks=seq(-200000,200000,0.5),
         ylim=c(0,300),
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(Slope), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(-3,-1,1,3,5,7,9,11), labels=c(-3,NA,1,NA,5,NA,9,NA), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=LitterQuantiles[LitterQuantiles$components=="slope",c("median")], col=PlotCols[5], lwd=2)
      
    
      # PLOT D
      plot(LitterValuesObserved~LitterValuesPredictedLAI, type='n',
           xlab=NA,
           ylab=NA,
           cex.lab=TextSz,
           xlim=c(4,12), ylim=c(4,12),
           xaxt='n', yaxt='n')
      axis(side=1, at=c(4,8,12), cex.axis=AxisSz)
      axis(side=2, at=c(4,8,12), cex.axis=AxisSz)
      points(x=LitterValuesPredictedLAI[TestPlotIDs=="A"], y=LitterValuesObserved[TestPlotIDs=="A"],
             pch=16, col=adjustcolor(A.color,alpha.f=0.02))
      points(x=LitterValuesPredictedLAI[TestPlotIDs=="L"], y=LitterValuesObserved[TestPlotIDs=="L"],
             pch=16, col=adjustcolor(L.color,alpha.f=0.02))
      points(x=LitterValuesPredictedLAI[TestPlotIDs=="P"], y=LitterValuesObserved[TestPlotIDs=="P"],
             pch=16, col=adjustcolor(P.color,alpha.f=0.02))
      abline(a=0,b=1,lty=2)
      mtext(expression(Observed~Litterfall~(Mg~ha^{-1}~yr^{-1})), side=2, line=2, cex=LabSz)
      mtext(expression(Predicted~Litterfall~(Mg~ha^{-1}~yr^{-1})), side=1, line=2.5, cex=LabSz)
      
  
    # PLOT E- histogram of r values between observed ANPP and ANPP predicted by total leaf area
    hist(LitterLAIRpt$r,
         main=NA,
         col='black', border="white",
         xlim=c(0,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,250),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,125,250), cex.axis=AxisSz)
    abline(v=LitterLAIQuantiles[LitterLAIQuantiles$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=LitterLAIQuantiles[LitterLAIQuantiles$components=="r",c("median")], col=PlotCols[5], lwd=3)
    
    # PLOT F- histogram of slope values between observed ANPP and ANPP predicted by total leaf area
    hist(LitterLAIRpt$slope,
         main=NA,
         col='black', border="white",
         cex.lab=TextSz,
         xlim=c(-3,11),breaks=seq(-200000,200000,0.5),
         ylim=c(0,300),
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(Slope), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(-3,-1,1,3,5,7,9,11), labels=c(-3,NA,1,NA,5,NA,9,NA), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=LitterLAIQuantiles[LitterLAIQuantiles$components=="slope",c("median")], col=PlotCols[5], lwd=2)
    
      # PLOT G
       plot(LitterValuesObserved~LitterValuesPredictedRH, type='n',
           xlab=NA,
           ylab=NA,
           cex.lab=TextSz,
           xlim=c(4,12), ylim=c(4,12),
           xaxt='n', yaxt='n')
      axis(side=1, at=c(4,8,12), cex.axis=AxisSz)
      axis(side=2, at=c(4,8,12), cex.axis=AxisSz)
      points(x=LitterValuesPredictedRH[TestPlotIDs=="A"], y=LitterValuesObserved[TestPlotIDs=="A"],
             pch=16, col=adjustcolor(A.color,alpha.f=0.02))
      points(x=LitterValuesPredictedRH[TestPlotIDs=="L"], y=LitterValuesObserved[TestPlotIDs=="L"],
             pch=16, col=adjustcolor(L.color,alpha.f=0.02))
      points(x=LitterValuesPredictedRH[TestPlotIDs=="P"], y=LitterValuesObserved[TestPlotIDs=="P"],
             pch=16, col=adjustcolor(P.color,alpha.f=0.02))
      abline(a=0,b=1,lty=2)
      mtext(expression(Observed~Litterfall~(Mg~ha^{-1}~yr^{-1})), side=2, line=2, cex=LabSz)
      mtext(expression(Predicted~Litterfall~(Mg~ha^{-1}~yr^{-1})), side=1, line=2.5, cex=LabSz)
  
    # PLOT H- histogram of r values between observed ANPP and ANPP predicted by lidar DRH profiles.
    hist(LitterRHRpt$r,
         main=NA,
         col='black', border="white",
         xlim=c(0,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,250),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,125,250), cex.axis=AxisSz)
    abline(v=LitterRHQuantiles[LitterRHQuantiles$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=LitterRHQuantiles[LitterRHQuantiles$components=="r",c("median")], col=PlotCols[5], lwd=2)
    
    # PLOT I- histogram of slope values between observed ANPP and ANPP predicted by lidar DRH profiles.
    hist(LitterRHRpt$slope,
         main=NA,
         col='black', border="white",
         cex.lab=TextSz,
         xlim=c(-3,11),breaks=seq(-200000,200000,0.5),
         ylim=c(0,300),
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(Slope), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(-3,-1,1,3,5,7,9,11), labels=c(-3,NA,1,NA,5,NA,9,NA), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=LitterRHQuantiles[LitterLAIQuantiles$components=="slope",c("median")], col=PlotCols[5], lwd=2)
      
      mtext("Litter productivity predicted from vertical leaf-area profiles", side=3, outer=T, cex=TextSz, line=-2)
      mtext("Litter productivity predicted from total leaf area", side=3, outer=T, cex=TextSz, line=-20)
      mtext("Litter productivity predicted from LiDAR discrete relative heights", side=3, outer=T, cex=TextSz, line=-39)
      
  dev.off()

```

```{r Figure S9, include=FALSE, eval=T}

PlotCols <- c("#F0EA73", #1 yellow
              "#D15B5B", #2 salmon
              "#517FE8", #3 blue
              "#8D8D8D", #4 grey
              "#39A23F", #5 green
              "#E066C4", #6 pink
              "#E98628", #7 gold
              "#8355B8") #8 purple

A.color <- "#4591A3" #alluvial
L.color <- "#8B6443" #plateau
P.color <- "#B8254D" #slope


# Results Figure S9- Repeat Figure 2 from main text, but for wood production results (instead of total ANPP).
  PointSz <- 1
  TextSz <- 1.2
  LabSz <- 0.8
  AxisSz <- 1.2
  
  
  tiff("Figure S9.tiff", width=7,height=7.5,units="in",res=300)
  par(mfrow=c(3,3), mar=c(4,4,3,1),oma=c(1,1,1,1), family="serif", xpd=F)
  
  
      # PLOT A
      plot(WoodValuesObserved~WoodValuesPredicted, type='n',
           xlab=NA,ylab=NA,
           cex.lab=TextSz,
           xlim=c(3,7), ylim=c(3,7.5),
           xaxt='n', yaxt='n')
      axis(side=1, at=c(3,5,7), cex.axis=AxisSz)
      axis(side=2, at=c(3,5,7), cex.axis=AxisSz)
      points(x=WoodValuesPredicted[TestPlotIDs=="A"], y=WoodValuesObserved[TestPlotIDs=="A"],
             pch=16, col=adjustcolor(A.color,alpha.f=0.02))
      points(x=WoodValuesPredicted[TestPlotIDs=="L"], y=WoodValuesObserved[TestPlotIDs=="L"],
             pch=16, col=adjustcolor(L.color,alpha.f=0.02))
      points(x=WoodValuesPredicted[TestPlotIDs=="P"], y=WoodValuesObserved[TestPlotIDs=="P"],
             pch=16, col=adjustcolor(P.color,alpha.f=0.02))
      abline(a=0,b=1,lty=2)
      mtext(expression(Observed~Productivity~(Mg~ha^{-1}~yr^{-1})), side=2, line=2, cex=LabSz)
      mtext(expression(Predicted~Productivity~(Mg~ha^{-1}~yr^{-1})), side=1, line=2.5, cex=LabSz)
      
      legend(x=3,y=7,
        c("Alluvial", "Plateau","Slope"),
        col=c(A.color,L.color, P.color),
        bty='n', cex=TextSz, pch=20, pt.cex=1.5)
              
   # PLOT B- histogram of r values between observed ANPP and ANPP predicted by leaf-area profiles
    hist(WoodRpt$r,
         main=NA,
         col='black', border="white",
         xlim=c(0,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,600),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,300,600), cex.axis=AxisSz)
    abline(v=WoodQuantiles[WoodQuantiles$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=WoodQuantiles[WoodQuantiles$components=="r",c("median")], col=PlotCols[5], lwd=2)

    # PLOT C- histogram of slope values between observed ANPP and ANPP predicted by leaf-area profiles
    hist(WoodRpt$slope,
         main=NA,
         col='black', border="white",
         cex.lab=TextSz,
         xlim=c(-7,7),breaks=seq(-200000,200000,0.5),
         ylim=c(0,300),
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(Slope), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(-7,-5,-3,-1,1,3,5,7), labels=c(-7,NA,-3,NA,1,NA,5,NA), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=WoodQuantiles[WoodQuantiles$components=="slope",c("median")], col=PlotCols[5], lwd=2)
    
    # PLOT D
          plot(WoodValuesObserved~WoodValuesPredictedLAI, type='n',
           xlab=NA,ylab=NA,
           cex.lab=TextSz,
           xlim=c(3,7), ylim=c(3,7.5),
           xaxt='n', yaxt='n')
      axis(side=1, at=c(3,5,7), cex.axis=AxisSz)
      axis(side=2, at=c(3,5,7), cex.axis=AxisSz)
      points(x=WoodValuesPredictedLAI[TestPlotIDs=="A"], y=WoodValuesObserved[TestPlotIDs=="A"],
             pch=16, col=adjustcolor(A.color,alpha.f=0.02))
      points(x=WoodValuesPredictedLAI[TestPlotIDs=="L"], y=WoodValuesObserved[TestPlotIDs=="L"],
             pch=16, col=adjustcolor(L.color,alpha.f=0.02))
      points(x=WoodValuesPredictedLAI[TestPlotIDs=="P"], y=WoodValuesObserved[TestPlotIDs=="P"],
             pch=16, col=adjustcolor(P.color,alpha.f=0.02))
      abline(a=0,b=1,lty=2)
      mtext(expression(Observed~Productivity~(Mg~ha^{-1}~yr^{-1})), side=2, line=2, cex=LabSz)
      mtext(expression(Predicted~Productivity~(Mg~ha^{-1}~yr^{-1})), side=1, line=2.5, cex=LabSz)
      
      
    # PLOT E- histogram of r values between observed ANPP and ANPP predicted by total leaf area
    hist(WoodLAIRpt$r,
         main=NA,
         col='black', border="white",
         xlim=c(0,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,600),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,300,600), cex.axis=AxisSz)
    abline(v=WoodLAIQuantiles[WoodLAIQuantiles$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=WoodLAIQuantiles[WoodLAIQuantiles$components=="r",c("median")], col=PlotCols[5], lwd=3)
    
    # PLOT F- histogram of slope values between observed ANPP and ANPP predicted by total leaf area
    hist(WoodLAIRpt$slope,
         main=NA,
         col='black', border="white",
         cex.lab=TextSz,
         xlim=c(-7,7),breaks=seq(-200000,200000,0.5),
         ylim=c(0,500),
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(Slope), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(-7,-5,-3,-1,1,3,5,7), labels=c(-7,NA,-3,NA,1,NA,5,NA), cex.axis=AxisSz)
    axis(side=2, at=c(0,250,500), cex.axis=AxisSz)
    abline(v=WoodLAIQuantiles[WoodLAIQuantiles$components=="slope",c("median")], col=PlotCols[5], lwd=2)
  
      # PLOT G
       plot(WoodValuesObserved~WoodValuesPredictedRH, type='n',
           xlab=NA,
           ylab=NA,
           cex.lab=TextSz,
           xlim=c(3,7), ylim=c(3,7.5),
           xaxt='n', yaxt='n')
      axis(side=1, at=c(3,5,7), cex.axis=AxisSz)
      axis(side=2, at=c(3,5,7), cex.axis=AxisSz)
      points(x=WoodValuesPredictedRH[TestPlotIDs=="A"], y=WoodValuesObserved[TestPlotIDs=="A"],
             pch=16, col=adjustcolor(A.color,alpha.f=0.02))
      points(x=WoodValuesPredictedRH[TestPlotIDs=="L"], y=WoodValuesObserved[TestPlotIDs=="L"],
             pch=16, col=adjustcolor(L.color,alpha.f=0.02))
      points(x=WoodValuesPredictedRH[TestPlotIDs=="P"], y=WoodValuesObserved[TestPlotIDs=="P"],
             pch=16, col=adjustcolor(P.color,alpha.f=0.02))
      abline(a=0,b=1,lty=2)
      mtext(expression(Observed~Productivity~(Mg~ha^{-1}~yr^{-1})), side=2, line=2, cex=LabSz)
      mtext(expression(Predicted~Productivity~(Mg~ha^{-1}~yr^{-1})), side=1, line=2.5, cex=LabSz)
  
    # PLOT H- histogram of r values between observed ANPP and ANPP predicted by lidar DRH profiles.
    hist(WoodRHRpt$r,
         main=NA,
         col='black', border="white",
         xlim=c(0,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,600),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,300,600), cex.axis=AxisSz)
    abline(v=WoodRHQuantiles[WoodRHQuantiles$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=WoodRHQuantiles[WoodRHQuantiles$components=="r",c("median")], col=PlotCols[5], lwd=2)
    
    # PLOT I- histogram of slope values between observed ANPP and ANPP predicted by lidar DRH profiles.
    hist(WoodRHRpt$slope,
         main=NA,
         col='black', border="white",
         cex.lab=TextSz,
         xlim=c(-7,7),breaks=seq(-200000,200000,0.5),
         ylim=c(0,300),
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n')
    mtext(expression(Slope), side=1, line=2.5, cex=LabSz)
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(-7,-5,-3,-1,1,3,5,7), labels=c(-7,NA,-3,NA,1,NA,5,NA), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=WoodRHQuantiles[WoodLAIQuantiles$components=="slope",c("median")], col=PlotCols[5], lwd=2)
      
      mtext("Wood productivity predicted from vertical leaf-area profiles", side=3, outer=T, cex=TextSz, line=-2)
      mtext("Wood productivity predicted from total leaf area", side=3, outer=T, cex=TextSz, line=-20)
      mtext("Wood productivity predicted from LiDAR discrete relative heights", side=3, outer=T, cex=TextSz, line=-39)
    
dev.off()

```

```{r Figure S10, include=FALSE, eval=T}

# Compare R^2 and slopes of models of vertical leaf-area profiles, vertical light transmission, and vertical light absorption
tiff("Figure S10.tiff", height=10, width=8, units="in", res=300)  
  par(mfrow=c(5,3), oma=c(3,6,2,0), mar=c(2,2,1,0), family="serif")
  TextSz <- 1.2
  LabSz <- 0.9
  AxisSz <- 1.2
  
  # R-squared values
    hist(LitterRpt$r,
           main="Litter",
           col='black', border="white",
           xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
           ylim=c(0,300),
           cex.lab=TextSz,cex.main=TextSz+0.2,
           xlab=NA,ylab=NA,
           xaxt='n', yaxt='n')
      mtext(expression(Frequency), side=2, line=2, cex=LabSz)
      mtext("Leaf-area", side=2, line=5.5, cex=TextSz)
      axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
      axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
      abline(v=LitterQuantiles[LitterQuantiles$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
      abline(v=LitterQuantiles[LitterQuantiles$components=="r",c("median")], col=PlotCols[5], lwd=2)
      text("A", x=-0.05, y=300, cex=TextSz)
      
     hist(WoodRpt$r,
           main="Wood",
           col='black', border="white",
          xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
           ylim=c(0,300),
           cex.lab=TextSz,cex.main=TextSz+0.2,
           xlab=NA,ylab=NA,
           xaxt='n', yaxt='n')
      axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
      axis(side=2, at=c(0,150,300), labels = NA, cex.axis=AxisSz)
      abline(v=WoodQuantiles[WoodQuantiles$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
      abline(v=WoodQuantiles[WoodQuantiles$components=="r",c("median")], col=PlotCols[5], lwd=2)
      text("B", x=-0.05, y=300, cex=TextSz)
      
      hist(TotalRpt$r,
           main="ANPP",
           col='black', border="white",
          xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
           ylim=c(0,300),
           cex.lab=TextSz,cex.main=TextSz+0.2,
           xlab=NA,ylab=NA,
           xaxt='n', yaxt='n')
      axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
      axis(side=2, at=c(0,150,300), labels = NA, cex.axis=AxisSz)
      abline(v=TotalQuantiles[TotalQuantiles$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
      abline(v=TotalQuantiles[TotalQuantiles$components=="r",c("median")], col=PlotCols[5], lwd=2)
      text("C", x=-0.05, y=300, cex=TextSz)
      
    hist(LitterRpt_tra$r,
           main=NA,
           col='black', border="white",
          xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
           ylim=c(0,300),
           cex.lab=TextSz,
           xlab=NA,ylab=NA,
           xaxt='n', yaxt='n')
      mtext("Light-transmittance", side=2, line=5.5, cex=TextSz)
      mtext(expression(Frequency), side=2, line=2, cex=LabSz)
      axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
      axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
      abline(v=LitterQuantiles_tra[LitterQuantiles_tra$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
      abline(v=LitterQuantiles_tra[LitterQuantiles_tra$components=="r",c("median")], col=PlotCols[5], lwd=2)
      text("D", x=-0.05, y=300, cex=TextSz)
      
     hist(WoodRpt_tra$r,
           main=NA,
           col='black', border="white",
          xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
           ylim=c(0,300),
           cex.lab=TextSz,
           xlab=NA,ylab=NA,
           xaxt='n', yaxt='n')
      axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
      axis(side=2, at=c(0,150,300), labels = NA, cex.axis=AxisSz)
      abline(v=WoodQuantiles_tra[WoodQuantiles_tra$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
      abline(v=WoodQuantiles_tra[WoodQuantiles_tra$components=="r",c("median")], col=PlotCols[5], lwd=2)
      text("E", x=-0.05, y=300, cex=TextSz)
      
      hist(TotalRpt_tra$r,
           main=NA,
           col='black', border="white",
          xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
           ylim=c(0,300),
           cex.lab=TextSz,
           xlab=NA,ylab=NA,
           xaxt='n', yaxt='n')
      axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
      axis(side=2, at=c(0,150,300), labels = NA, cex.axis=AxisSz)
      abline(v=TotalQuantiles_tra[TotalQuantiles_tra$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
      abline(v=TotalQuantiles_tra[TotalQuantiles_tra$components=="r",c("median")], col=PlotCols[5], lwd=2)
      text("F", x=-0.05, y=300, cex=TextSz)
      
      hist(LitterRpt_abs$r,
           main=NA,
           col='black', border="white",
          xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
           ylim=c(0,300),
           cex.lab=TextSz,
           xlab=NA,ylab=NA,
           xaxt='n', yaxt='n')
      mtext("Light-absorption", side=2, line=5.5, cex=TextSz)
      mtext(expression(Frequency), side=2, line=2, cex=LabSz)
      axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
      axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
      abline(v=LitterQuantiles_abs[LitterQuantiles_abs$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
      abline(v=LitterQuantiles_abs[LitterQuantiles_abs$components=="r",c("median")], col=PlotCols[5], lwd=2)
      text("G", x=-0.05, y=300, cex=TextSz)
      
     hist(WoodRpt_abs$r,
           main=NA,
           col='black', border="white",
          xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
           ylim=c(0,300),
           cex.lab=TextSz,
           xlab=NA,ylab=NA,
           xaxt='n', yaxt='n')
      axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
      axis(side=2, at=c(0,150,300), labels = NA, cex.axis=AxisSz)
      abline(v=WoodQuantiles_abs[WoodQuantiles_abs$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
      abline(v=WoodQuantiles_abs[WoodQuantiles_abs$components=="r",c("median")], col=PlotCols[5], lwd=2)
      text("H", x=-0.05, y=300, cex=TextSz)
      
      hist(TotalRpt_abs$r,
           main=NA,
           col='black', border="white",
          xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
           ylim=c(0,300),
           cex.lab=TextSz,
           xlab=NA,ylab=NA,
           xaxt='n', yaxt='n')
      axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
      axis(side=2, at=c(0,150,300), labels = NA, cex.axis=AxisSz)
      abline(v=TotalQuantiles_abs[TotalQuantiles_abs$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
      abline(v=TotalQuantiles_abs[TotalQuantiles_abs$components=="r",c("median")], col=PlotCols[5], lwd=2)    
      text("I", x=-0.05, y=300, cex=TextSz)
      
    hist(LitterRpt_lai_tra$r,
           main=NA,
           col='black', border="white",
          xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
           ylim=c(0,300),
           cex.lab=TextSz,
           xlab=NA,ylab=NA,
           xaxt='n', yaxt='n')
      mtext("Leaf-area +", side=2, line=5.5, cex=TextSz)
      mtext("light-transmittance", side=2, line=4, cex=TextSz)
      mtext(expression(Frequency), side=2, line=2, cex=LabSz)
      axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
      axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
      abline(v=LitterQuantiles_lai_tra[LitterQuantiles_lai_tra$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
      abline(v=LitterQuantiles_lai_tra[LitterQuantiles_lai_tra$components=="r",c("median")], col=PlotCols[5], lwd=2)
      text("J", x=-0.05, y=300, cex=TextSz)
      
     hist(WoodRpt_lai_tra$r,
           main=NA,
           col='black', border="white",
          xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
           ylim=c(0,300),
           cex.lab=TextSz,
           xlab=NA,ylab=NA,
           xaxt='n', yaxt='n')
      axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
      axis(side=2, at=c(0,150,300), labels = NA, cex.axis=AxisSz)
      abline(v=WoodQuantiles_lai_tra[WoodQuantiles_lai_tra$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
      abline(v=WoodQuantiles_lai_tra[WoodQuantiles_lai_tra$components=="r",c("median")], col=PlotCols[5], lwd=2)
      text("K", x=-0.05, y=300, cex=TextSz)
      
      hist(TotalRpt_lai_tra$r,
           main=NA,
           col='black', border="white",
          xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
           ylim=c(0,300),
           cex.lab=TextSz,
           xlab=NA,ylab=NA,
           xaxt='n', yaxt='n')
      axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
      axis(side=2, at=c(0,150,300), labels = NA, cex.axis=AxisSz)
      abline(v=TotalQuantiles_lai_tra[TotalQuantiles_lai_tra$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
      abline(v=TotalQuantiles_lai_tra[TotalQuantiles_lai_tra$components=="r",c("median")], col=PlotCols[5], lwd=2)
      text("L", x=-0.05, y=300, cex=TextSz)
    
      hist(LitterRpt_lai_abs$r,
           main=NA,
           col='black', border="white",
          xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
           ylim=c(0,300),
           cex.lab=TextSz,
           xlab=NA,ylab=NA,
           xaxt='n', yaxt='n')
      mtext("Leaf-area +", side=2, line=5.5, cex=TextSz)
      mtext("light-absorption", side=2, line=4, cex=TextSz)
      mtext(expression(Frequency), side=2, line=2, cex=LabSz)
      mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
      axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
      axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
      abline(v=LitterQuantiles_lai_abs[LitterQuantiles_lai_abs$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
      abline(v=LitterQuantiles_lai_abs[LitterQuantiles_lai_abs$components=="r",c("median")], col=PlotCols[5], lwd=2)
      text("M", x=-0.05, y=300, cex=TextSz)
      
     hist(WoodRpt_lai_abs$r,
           main=NA,
           col='black', border="white",
          xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
           ylim=c(0,300),
           cex.lab=TextSz,
           xlab=NA,ylab=NA,
           xaxt='n', yaxt='n')
      mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
      axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
      axis(side=2, at=c(0,150,300), labels = NA, cex.axis=AxisSz)
      abline(v=WoodQuantiles_lai_abs[WoodQuantiles_lai_abs$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
      abline(v=WoodQuantiles_lai_abs[WoodQuantiles_lai_abs$components=="r",c("median")], col=PlotCols[5], lwd=2)
      text("N", x=-0.05, y=300, cex=TextSz)
      
      hist(TotalRpt_lai_abs$r,
           main=NA,
           col='black', border="white",
          xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
           ylim=c(0,300),
           cex.lab=TextSz,
           xlab=NA,ylab=NA,
           xaxt='n', yaxt='n')
      mtext(expression(r^{2}), side=1, line=2.5, cex=LabSz)
      axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
      axis(side=2, at=c(0,150,300), labels = NA, cex.axis=AxisSz)
      abline(v=TotalQuantiles_lai_abs[TotalQuantiles_lai_abs$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
      abline(v=TotalQuantiles_lai_abs[TotalQuantiles_lai_abs$components=="r",c("median")], col=PlotCols[5], lwd=2)
      text("O", x=-0.05, y=300, cex=TextSz)
  
  dev.off()
  
```

```{r Figure S11, include=FALSE, eval=T}

  A.color <- "#4591A3" #alluvial
  L.color <- "#8B6443" #plateau
  P.color <- "#B8254D" #slope

# Open plot tiff
tiff("Figure S11.tiff", width=8, height=5, units="in", res=300)
  par(mfrow=c(1,2), family="serif")
  
  # Plot relationship between wood and litter production in CARBONO field plots
    plot(Wood~Litter, data=CARBONO,
         type='n',
         xlab=expression(Litter~Production~(Mg~ha^{-1}~yr^{-1})),
         ylab=expression(Wood~Production~(Mg~ha^{-1}~yr^{-1})))
    points(Wood~Litter, data=CARBONO[CARBONO$Type=="A",], col=A.color, pch=20)
    points(Wood~Litter, data=CARBONO[CARBONO$Type=="L",], col=L.color, pch=20)
    points(Wood~Litter, data=CARBONO[CARBONO$Type=="P",], col=P.color, pch=20)
        legend(x=9,y=7.1,
        c("Alluvial", "Plateau","Slope"),
        col=c(A.color,L.color, P.color),
        bty='n', pch=20, pt.cex=1.5)
      
     rVal <- round(cor(CARBONO$Wood, CARBONO$Litter),2) # calculate correlation coefficient
     text(x=10, y=4.6, labels=paste("r =",rVal))
  
  # Plot relationship between total ANPP and total leaf area in CARBONO field plots 
    plot(ANPP~TotalLAI, data=CARBONO,
         type='n',
         ylab=expression(Total~ANPP~(Mg~ha^{-1}~yr^{-1})),
         xlab=expression(Leaf~Area~(m^{2}/m^{2})))
    points(ANPP~TotalLAI, data=CARBONO[CARBONO$Type=="A",], col=A.color, pch=20)
    points(ANPP~TotalLAI, data=CARBONO[CARBONO$Type=="L",], col=L.color, pch=20)
    points(ANPP~TotalLAI, data=CARBONO[CARBONO$Type=="P",], col=P.color, pch=20)
    
     rVal <- round(cor(CARBONO$ANPP, CARBONO$TotalLAI),2) # calculate correlation coefficient
     text(x=4.5, y=11.6, labels=paste("r =",rVal))
   
dev.off()

```

```{r Figure S12, include=FALSE, eval=T}
# Define colors to be used in plots
  PlotCols <- c("#F0EA73", #1 yellow
                "#D15B5B", #2 salmon
                "#517FE8", #3 blue
                "#8D8D8D", #4 grey
                "#39A23F", #5 green
                "#E066C4", #6 pink
                "#E98628", #7 gold
                "#8355B8") #8 purple
# Define colors for plot edaphic classes
  A.color <- "#4591A3" #alluvial
  L.color <- "#8B6443" #plateau
  P.color <- "#B8254D" #slope
  
# Define plot parameters
  PointSz <- 1
  TextSz <- 1.2
  LabSz <- 1
  AxisSz <- 1.5

# Open tiff plot
  tiff("Figure S12.tiff",width=7,height=3,units = 'in', res = 300)
  par(mfrow=c(1,3), mar=c(4,4,3,1),oma=c(1,1,1,1), family="serif", xpd=F)

    # PLOT A- histogram of slope values between observed ANPP and ANPP predicted by leaf-area profiles
    hist(TotalRpt_simple$r,
         col='black', border="white",
         xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,300),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n',
         main="Vertical leaf-area profiles")
    mtext(expression(Frequency), side=2, line=2, cex=LabSz)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=TotalQuantiles_simple[TotalQuantiles_simple$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=TotalQuantiles_simple[TotalQuantiles_simple$components=="r",c("median")], col=PlotCols[5], lwd=2)
    text("A", x=-0.05, y=300, cex=TextSz)
    
    # PLOT B- histogram of slope values between observed ANPP and ANPP predicted by total leaf area
    hist(TotalLAIRpt$r,
         col='black', border="white",
         xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,300),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n',
         main="Total leaf area")
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=TotalLAIQuantiles[TotalLAIQuantiles$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=TotalLAIQuantiles[TotalLAIQuantiles$components=="r",c("median")], col=PlotCols[5], lwd=2)
    text("B", x=-0.05, y=300, cex=TextSz)
    
    # PLOT C- histogram of slope values between observed ANPP and ANPP predicted by total leaf area
    hist(TotalRHRpt_simple$r,
         col='black', border="white",
         xlim=c(-0.05,1),breaks=seq(0,1,length.out = 30),
         ylim=c(0,300),
         cex.lab=TextSz,
         xlab=NA,ylab=NA,
         xaxt='n', yaxt='n',
         main="DRH percentiles")
    mtext(expression(r^{2}), side=1, line=0, cex=LabSz, outer=T)
    axis(side=1, at=c(0,0.25,0.5,0.75,1.0),labels=c(0,NA,0.5,NA,1.0), cex.axis=AxisSz)
    axis(side=2, at=c(0,150,300), cex.axis=AxisSz)
    abline(v=TotalRHQuantiles_simple[TotalRHQuantiles_simple$components=="r",c("lower","upper")], col=PlotCols[5], lty=3, lwd=2)
    abline(v=TotalRHQuantiles_simple[TotalRHQuantiles_simple$components=="r",c("median")], col=PlotCols[5], lwd=2)
    text("C", x=-0.05, y=300, cex=TextSz)
    
dev.off()

```

```{r Figure S13, include=FALSE, eval=T}
# Define plot parameters
  PointSz <- 1.5
  TextSz <- 1.4
  LineSz <- 2
  
# Open tiff plot
  tiff("Figure S13.tiff", width=7,height=7,units='in',res=300)
  par(mfrow=c(2,2), mar=c(4,4,3,1),oma=c(2,2,1,1), family="serif", xpd=F)
  
  # Plot the first component loading loading for each canopy height position, then plot 95% CI intervals.    
    plot(height~mean, data=TotalC1LoadingsSummary,
         type='l',lwd=2, bty='L',
         xlab=NA,
         main="Component 1",
         cex.lab=TextSz, cex.axis=TextSz,
         xlim=range(c(TotalC1LoadingsSummary$min, TotalC1LoadingsSummary$max)),
         ylab=NA)
    points(height~mean, data=TotalC1LoadingsSummary, pch=20)
    arrows(x0=TotalC1LoadingsSummary$min, x1=TotalC1LoadingsSummary$max, 
           y0=TotalC1LoadingsSummary$height, y1=TotalC1LoadingsSummary$height,
           angle=90, length=0.02, code=3)
    abline(v=0, col="red")
    text("A", x=-0.45, y=60, cex=TextSz)
  
  # Plot the second component loading loading for each canopy height position, then plot 95% CI intervals.      
    plot(height~mean, data=TotalC2LoadingsSummary,
         type='l',lwd=2, bty='L',
         xlab=NA,
         main="Component 2",
         cex.lab=TextSz, cex.axis=TextSz,
         xlim=range(c(TotalC2LoadingsSummary$min, TotalC2LoadingsSummary$max)),
         ylab=NA)
    points(height~mean, data=TotalC2LoadingsSummary, pch=20)
    arrows(x0=TotalC2LoadingsSummary$min, x1=TotalC2LoadingsSummary$max, 
           y0=TotalC2LoadingsSummary$height, y1=TotalC2LoadingsSummary$height,
           angle=90, length=0.02, code=3)
    abline(v=0, col="red")
    text("B", x=-0.4, y=60, cex=TextSz)
  
  # Plot the third component loading loading for each canopy height position, then plot 95% CI intervals.
    plot(height~mean, data=TotalC3LoadingsSummary,
         type='l',lwd=2, bty='L',
         xlab=NA,
         main="Component 3",
         cex.lab=TextSz, cex.axis=TextSz,
         xlim=range(c(TotalC3LoadingsSummary$min, TotalC3LoadingsSummary$max)),
         ylab=NA)
    points(height~mean, data=TotalC3LoadingsSummary, pch=20)
    arrows(x0=TotalC3LoadingsSummary$min, x1=TotalC3LoadingsSummary$max, 
           y0=TotalC3LoadingsSummary$height, y1=TotalC3LoadingsSummary$height,
           angle=90, length=0.02, code=3)
    abline(v=0, col="red")
    text("C", x=-0.42, y=60, cex=TextSz)
    mtext("Height (m)", side=2, outer=T, cex=TextSz)
    mtext("Loading value", side=1, outer=T, cex=TextSz)
    
  dev.off()
```